<!DOCTYPE html>
<html lang="en" class="scroll-smooth" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PaperX — Notes Generator (Material Style)</title>

  <script>
    (function () {
      try {
        var keys = ['cx-theme', 'theme', 'px-theme'];
        var mode = null;
        for (var i = 0; i < keys.length; i++) {
          var v = localStorage.getItem(keys[i]);
          if (v === 'dark' || v === 'light') { mode = v; break; }
        }
        if (!mode && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          mode = 'dark';
        }
        if (mode) {
          document.documentElement.setAttribute('data-theme', mode);
          document.documentElement.classList.toggle('dark', mode === 'dark');
        }
      } catch (e) { }
    })();
  </script>

  <!-- Tailwind + plugins -->
  <link rel="stylesheet" href="assets/css/tailwind.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script defer src="assets/js/analytics-tracker.js"></script>
  <script>
    // Use the same palette + mode behavior as other PaperX pages
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'ui-sans-serif', 'system-ui', '-apple-system', 'Segoe UI', 'Roboto', 'sans-serif'],
          },
          colors: {
            brand: { 900: '#1E1E2F', 700: '#4C2A59', 500: '#9E4B8A' },
            brandlt: { 50: '#FAF5FB', 100: '#F3E7F2', 200: '#E7D0E4', 300: '#D9B4D3', 400: '#C88DBA', 500: '#9E4B8A', 700: '#4C2A59', 900: '#1E1E2F' },
            surface: { DEFAULT: 'var(--surface)', dim: 'var(--surface-dim)', contrast: 'var(--surface-contrast)' }
          },
          boxShadow: {
            glow: '0 8px 30px rgba(158,75,138,0.35)',
            neon: '0 0 25px rgba(158,75,138,.35), 0 0 60px rgba(158,75,138,.25)',
            'e1': '0 1px 2px rgba(0,0,0,0.06)',
            'e2': '0 2px 6px rgba(0,0,0,0.08)',
            'e3': '0 6px 12px rgba(0,0,0,0.10)',
            'e4': '0 10px 16px rgba(0,0,0,0.12)'
          },
          keyframes: {
            in: { '0%': { opacity: 0, transform: 'translateY(6px)' }, '100%': { opacity: 1, transform: 'translateY(0)' } },
            pulsebar: { '0%': { width: '8%' }, '50%': { width: '55%' }, '100%': { width: '92%' } },
            shimmer: { '0%': { backgroundPosition: '-468px 0' }, '100%': { backgroundPosition: '468px 0' } }
          },
          animation: { in: 'in .25s ease-out', pulsebar: 'pulsebar 1.8s ease-in-out infinite', shimmer: 'shimmer 1.25s linear infinite' }
        }
      }
    }
  </script>

  <!-- Shared config + theme manager -->
  <script src="./config.js"></script>
  <script src="./auth.js" defer></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

  <!-- Code highlight / markdown / mermaid -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  <!-- Lottie Web Component for loader animation -->
  <script type="module" src="https://unpkg.com/@lottiefiles/dotlottie-wc@0.8.5/dist/dotlottie-wc.js"></script>

  <style>
    :root {
      /* PaperX light tokens */
      --surface: #ffffff;
      --surface-dim: #FBF8FC;
      --surface-contrast: #1E1E2F;
      --outline: rgba(30, 30, 47, 0.10);
      --muted: #5b6178;
      --elev: 1;
      --brand: #9E4B8A;
      --brand-strong: #4C2A59;
      --brand-soft: #F3E7F2;
      --chip: #FAF5FB;
      --kbd: #F3E7F2;
    }

    [data-theme="dark"] {
      /* PaperX dark tokens */
      --surface: #1E1E2F;
      --surface-dim: #201934;
      --surface-contrast: #EAEAF2;
      --outline: rgba(255, 255, 255, .12);
      --muted: #c9c6d8;
      --elev: 0;
      --brand: #9E4B8A;
      --brand-strong: #CA6CB3;
      --brand-soft: rgba(255, 255, 255, 0.06);
      --chip: rgba(255, 255, 255, 0.08);
      --kbd: rgba(255, 255, 255, 0.08);
    }

    html,
    body {
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    /* Background decorations to match other pages */
    .bg-grid-radial {
      background-color: var(--surface-dim);
      background-image: radial-gradient(circle at 20% 10%, rgba(158, 75, 138, .18), transparent 40%),
        radial-gradient(circle at 80% 15%, rgba(76, 42, 89, .22), transparent 45%),
        radial-gradient(circle at 55% 80%, rgba(250, 245, 251, .6), transparent 50%);
    }

    .glass {
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.65);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    [data-theme="dark"] .glass {
      background: rgba(15, 18, 38, 0.55);
      border-color: rgba(255, 255, 255, 0.08);
    }

    /* Prose tweaks */
    .prose :where(h1, h2, h3, h4) {
      scroll-margin-top: 6rem;
    }

    .prose pre {
      border-radius: .75rem;
      border: 1px solid var(--outline);
      background: #0b1020;
      color: #e5e7eb;
    }

    .prose code:not(pre code) {
      background: var(--kbd);
      padding: .18rem .4rem;
      border-radius: .35rem;
    }

    .prose img {
      border-radius: .75rem;
    }

    /* Scrollbars */
    .scrollbar-thin {
      scrollbar-width: thin;
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 6px;
      width: 6px;
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: #cdd4ff;
      border-radius: 9999px;
    }

    /* Ripple (Material state) */
    .ripple {
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }

    .ripple::after {
      content: '';
      position: absolute;
      inset: auto;
      width: 0;
      height: 0;
      border-radius: 9999px;
      background: currentColor;
      opacity: .12;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* Skeleton shimmer */
    .skeleton {
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.06) 25%, rgba(0, 0, 0, 0.12) 37%, rgba(0, 0, 0, 0.06) 63%);
      background-size: 800px 100%;
      animation: shimmer 1.25s linear infinite;
    }

    /* Glass */
    .glass {
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.65);
    }

    [data-theme="dark"] .glass {
      background: rgba(15, 18, 38, 0.55);
    }

    /* Emphasis styling for bold keywords (toggleable) */
    .emph-strong .prose strong {
      background: var(--brand-soft);
      color: var(--surface-contrast);
      padding: .06rem .25rem;
      border-radius: .25rem;
    }

    /* Citation pills */
    .citation-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 0 .5rem;
      height: 20px;
      line-height: 18px;
      border-radius: 9999px;
      border: 1px solid var(--outline);
      background: var(--chip);
      color: inherit;
      font-size: 11px;
      text-decoration: none;
      vertical-align: text-bottom;
    }

    .citation-pill img {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      object-fit: cover;
    }

    /* Citations section list: one line per item, clickable, hoverable */
    .citations-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: .35rem;
      margin-top: .5rem;
    }

    .citation-item {
      display: block;
      padding: .35rem .5rem;
      border-radius: .5rem;
      border: 1px solid var(--outline);
      background: var(--chip);
      color: inherit;
      font-size: .9rem;
      text-decoration: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .citation-item:hover {
      background: color-mix(in oklab, var(--brand-soft) 60%, transparent);
    }

    /* Related videos carousel */
    .yt-carousel {
      display: flex;
      gap: 1.5rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
      scroll-snap-type: x mandatory;
      scrollbar-width: thin;
    }

    .yt-carousel::-webkit-scrollbar {
      height: 8px;
    }

    .yt-carousel::-webkit-scrollbar-thumb {
      background: var(--outline);
      border-radius: 9999px;
    }

    .yt-card {
      flex: 0 0 260px;
      scroll-snap-align: start;
      border: 1px solid var(--outline);
      border-radius: 1rem;
      overflow: hidden;
      background: var(--surface);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      text-decoration: none;
      color: inherit;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      position: relative;
    }

    .yt-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 16px 28px rgba(37, 99, 235, 0.18);
    }

    .yt-thumb {
      position: relative;
      padding-top: 56.25%;
      background: #000;
    }

    .yt-thumb img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .yt-duration {
      position: absolute;
      bottom: 8px;
      right: 8px;
      padding: 2px 6px;
      border-radius: 9999px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .yt-hover-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(155deg, rgba(8, 7, 31, 0.75), rgba(88, 28, 135, 0.45));
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 2;
    }

    .yt-card:hover .yt-hover-overlay,
    .yt-card:focus-within .yt-hover-overlay {
      opacity: 1;
      pointer-events: auto;
    }

    .yt-hover-overlay .yt-hover-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 9999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 12px 22px rgba(15, 23, 42, 0.35);
      font-size: 0;
    }

    .yt-hover-overlay .yt-hover-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 24px rgba(15, 23, 42, 0.45);
    }

    .yt-hover-overlay .yt-hover-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .yt-hover-btn-play {
      background: linear-gradient(135deg, #4C2A59, #B06AB3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .yt-hover-btn-notes {
      background: linear-gradient(135deg, #4C2A59, #B06AB3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .yt-hover-btn-icon {
      font-size: 22px;
      line-height: 1;
      color: inherit;
      font-family: 'Material Symbols Rounded', 'Material Symbols Outlined', sans-serif;
      font-variation-settings: 'FILL' 0, 'wght' 500, 'GRAD' 0, 'opsz' 24;
    }

    .yt-body {
      padding: 0.75rem 0.95rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .yt-title {
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.3;
      overflow: hidden;
      display: -webkit-box;
      line-clamp: 2;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .yt-meta {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .yt-channel-logo {
      width: 28px;
      height: 28px;
      border-radius: 9999px;
      object-fit: cover;
      border: 1px solid var(--outline);
      flex-shrink: 0;
    }

    .yt-channel-name {
      font-weight: 600;
      color: var(--surface-contrast);
    }

    .yt-views {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .yt-skeleton-grid {
      display: flex;
      gap: 1.5rem;
      overflow: hidden;
    }

    .yt-skeleton-card {
      flex: 0 0 260px;
      height: 180px;
      border-radius: 1rem;
      background: rgba(148, 163, 184, 0.2);
    }

    /* Mobile adjustments: reduce Related Videos height */
    @media (max-width: 640px) {
      .yt-card {
        flex: 0 0 200px;
      }

      .yt-thumb {
        padding-top: 45%;
      }

      .yt-skeleton-card {
        flex: 0 0 200px;
        height: 130px;
      }

      .yt-skeleton-grid {
        gap: 1rem;
      }

      #relatedVideosSection .py-5 {
        padding-top: .75rem !important;
        padding-bottom: .75rem !important;
      }
    }

    /* Ensure the output area reserves space while loading */
    #outputWrap.loading {
      min-height: 360px;
    }
  </style>
  <style>
    /* Shared loader box to keep the animation perfectly square and responsive */
    .px-loader-box {
      width: clamp(180px, 45vw, 360px);
      aspect-ratio: 1 / 1;
    }

    .px-loader-box>dotlottie-wc {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body class="bg-[var(--surface-dim)] text-[var(--surface-contrast)] min-h-screen font-sans">
  <!-- Background theme (light/dark) -->
  <div aria-hidden="true" class="fixed inset-0 -z-10">
    <div class="absolute inset-0 bg-[var(--surface-dim)]"></div>
  </div>

  <!-- Top App Bar (PaperX style) -->
  <header
    class="sticky top-0 z-40 bg-white/70 dark:bg-brand-900/60 backdrop-blur supports-[backdrop-filter]:saturate-150 border-b border-black/5 dark:border-white/10">
    <div class="max-w-7xl mx-auto px-4 sm:px-6">
      <div class="h-16 flex items-center gap-4">
        <a href="index.html" class="flex items-center gap-2 min-w-0">
          <img src="assets/img/logo-light.svg" alt="Paper X" class="h-8 w-auto dark:hidden">
          <img src="assets/img/logo-dark.svg" alt="Paper X" class="h-8 w-auto hidden dark:block">
          <span class="sr-only">Paper X</span>
        </a>
        <div class="hidden sm:flex items-center gap-4 text-sm text-neutral-700 dark:text-white/85">
          <a href="./notes_marketplace.html"
            class="px-3 py-2 rounded-full hover:bg-black/5 dark:hover:bg-white/10">Marketplace</a>
          <a href="./upload_note.html" class="px-3 py-2 rounded-full hover:bg-black/5 dark:hover:bg-white/10">Upload
            Note</a>
        </div>
        <div class="ml-auto flex items-center gap-2">
          <button id="flashcardBtn"
            class="ripple hidden px-3 py-2 rounded-full bg-brand-500 text-white text-sm font-semibold shadow-glow transition disabled:opacity-60 disabled:cursor-not-allowed"
            disabled aria-disabled="true">Flashcards</button>
          <button id="mcqBtn"
            class="ripple hidden px-3 py-2 rounded-full bg-brand-500 text-white text-sm font-semibold shadow-glow transition disabled:opacity-60 disabled:cursor-not-allowed"
            disabled aria-disabled="true">MCQ</button>
          <button id="densityBtn"
            class="ripple px-3 py-2 rounded-full border text-sm hover:bg-brandlt-100 dark:hover:bg-white/10 transition"
            style="border-color: var(--outline)" title="Toggle density">Density</button>
          <button id="themeBtn"
            class="ripple px-3 py-2 rounded-full border text-sm hover:bg-brandlt-100 dark:hover:bg-white/10 transition"
            style="border-color: var(--outline)" title="Toggle theme">Theme</button>
        </div>
      </div>
    </div>
  </header>

  <!-- Related Videos -->
  <section id="relatedVideosSection" class="max-w-7xl mx-auto px-4 sm:px-6 mt-6 hidden">
    <div class="rounded-2xl glass border shadow-glow"
      style="border-color: var(--outline); background: color-mix(in oklab, var(--surface) 78%, transparent);">
      <div class="flex items-center justify-between gap-3 px-6 py-5 border-b flex-wrap"
        style="border-color: var(--outline)">
        <div class="min-w-0">
          <h2 class="text-base sm:text-lg font-semibold tracking-tight">Related YouTube Videos</h2>
          <p id="relatedVideosSummary" class="text-xs sm:text-sm text-[var(--muted)]">Enter a topic to discover
            supporting videos.</p>
        </div>
        <div class="flex items-center gap-3 shrink-0">
          <select id="videoLanguageSelect"
            class="rounded-xl border px-3 py-2 text-sm font-medium bg-transparent text-current focus:outline-none focus:ring-2 focus:ring-[var(--brand-soft)] transition"
            style="border-color: var(--outline)" aria-label="Select video language">
            <option value="English">English</option>
            <option value="Tamil">Tamil</option>
            <option value="Hindi">Hindi</option>
            <option value="Telugu">Telugu</option>
            <option value="Malayalam">Malayalam</option>
          </select>
          <button id="refreshVideosBtn"
            class="ripple inline-flex items-center gap-2 rounded-xl border px-3 py-2 text-sm font-medium hover:bg-[var(--brand-soft)] transition shrink-0"
            style="border-color: var(--outline)">
            <span class="material-symbols-outlined text-base">refresh</span>
            Refresh
          </button>
        </div>
      </div>
      <div id="relatedVideosSkeleton" class="px-6 py-5">
        <div class="yt-skeleton-grid">
          <div class="yt-skeleton-card skeleton"></div>
          <div class="yt-skeleton-card skeleton"></div>
          <div class="yt-skeleton-card skeleton"></div>
        </div>
      </div>
      <div id="relatedVideosWrap" class="px-6 py-5 hidden">
        <div id="relatedVideoCarousel" class="yt-carousel"></div>
      </div>
      <div id="relatedVideosEmpty" class="px-6 pb-6 text-sm text-[var(--muted)] hidden">
        Videos will appear once a topic is generated.
      </div>
    </div>
  </section>


  <!-- Main layout -->
  <main class="max-w-7xl mx-auto px-4 sm:px-6 py-6 grid grid-cols-1 lg:grid-cols-12 gap-6">

    <!-- Left column -->
    <aside class="space-y-4 lg:col-span-3">

      <!-- Input Card -->
      <section class="rounded-2xl glass p-4 sm:p-5 border shadow-glow animate-in"
        style="border-color: var(--outline); background: color-mix(in oklab, var(--surface) 75%, transparent)">
        <div class="">
          <label class="block text-sm font-medium mb-2 hidden sm:block">Topic</label>
          <div class="flex gap-2 items-center">
            <input id="topic" type="text" placeholder="e.g., Support Vector Machine"
              class="w-full px-4 py-3 rounded-xl border focus:outline-none focus:ring-2 focus:ring-brand-500/60 focus:border-brand-500"
              style="border-color: var(--outline); background: var(--surface); color: var(--surface-contrast)" />
            <button id="generateBtn"
              class="ripple px-3 py-2 sm:px-4 sm:py-3 rounded-xl hover:opacity-95 text-white font-medium text-sm sm:text-base shadow-neon transition disabled:opacity-50 disabled:cursor-not-allowed"
              style="background-image: linear-gradient(135deg, var(--brand) 0%, var(--brand-strong) 100%); box-shadow: 0 12px 32px rgba(158,75,138,0.35);">
              Generate
            </button>
            <button id="regenBtnMobile"
              class="ripple sm:hidden px-3 py-2 rounded-xl border text-sm hover:bg-[var(--brand-soft)] transition disabled:opacity-50 disabled:cursor-not-allowed"
              style="border-color: var(--outline)">Regenerate</button>
          </div>
          <!-- Degree selector -->
          <div id="degreeRow" class="hidden mt-3 grid grid-cols-1 sm:grid-cols-2 gap-2 items-center">
            <div class="flex items-center gap-2">
              <label for="degreeSelect" class="text-xs font-medium shrink-0">Degree</label>
              <select id="degreeSelect"
                class="w-full px-3 py-2 rounded-xl border bg-transparent text-sm focus:outline-none focus:ring-2 focus:ring-brand-500/50"
                style="border-color: var(--outline)">
                <option value="">Select degree…</option>
                <option value="custom">Other…</option>
              </select>
            </div>
            <div id="degreeCustomRow" class="hidden sm:col-span-1">
              <input id="degreeCustom" type="text" placeholder="Type your degree (e.g., B.Tech)"
                class="w-full px-3 py-2 rounded-xl border bg-transparent text-sm focus:outline-none focus:ring-2 focus:ring-brand-500/50"
                style="border-color: var(--outline); background: var(--surface); color: var(--surface-contrast)" />
            </div>
          </div>
          <div class="hidden sm:flex items-center gap-2 mt-3">
            <button id="regenBtn"
              class="ripple px-3 py-2 rounded-xl border hover:bg-[var(--brand-soft)] transition disabled:opacity-50 disabled:cursor-not-allowed"
              style="border-color: var(--outline)">Regenerate</button>
            <button id="cancelBtn"
              class="ripple px-3 py-2 rounded-xl border hover:bg-[var(--brand-soft)] transition disabled:opacity-50 disabled:cursor-not-allowed"
              style="border-color: var(--outline)" disabled>Cancel</button>
            <div class="text-xs text-[var(--muted)] ml-auto"><span id="domainsHint">Sources: auto</span></div>
          </div>
        </div>

        <!-- Stepper / progress -->
        <div class="pt-4 hidden sm:block">
          <ol class="grid grid-cols-5 gap-2 text-[11px] text-center text-[var(--muted)]">
            <li class="step" data-step="start">Start</li>
            <li class="step" data-step="search_results">Search</li>
            <li class="step" data-step="fetch_done">Parse</li>
            <li class="step" data-step="llm_done">Generate</li>
            <li class="step" data-step="final">Done</li>
          </ol>
          <div class="h-1.5 mt-2 bg-[var(--brand-soft)] rounded-full overflow-hidden">
            <div id="progressBar" class="h-full bg-brand-500 w-0 transition-all"></div>
          </div>
        </div>
      </section>



      <!-- Related Images -->
      <section class="hidden" style="border-color: var(--outline);">
        <div class="p-4 sm:p-5">
          <h3 class="text-sm font-semibold mb-3">Related Images</h3>
          <div id="images" class="grid grid-cols-3 gap-2">
            <!-- skeletons -->
            <div class="h-24 rounded-lg skeleton"></div>
            <div class="h-24 rounded-lg skeleton"></div>
            <div class="h-24 rounded-lg skeleton"></div>
          </div>
        </div>
      </section>

      <!-- Contents (sticky) -->
      <section class="rounded-2xl glass border shadow-glow sticky top-24 hidden sm:block"
        style="border-color: var(--outline);">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between mb-2">
            <h3 class="text-sm font-semibold">Contents</h3>
            <div class="text-xs text-[var(--muted)] hidden" id="noteMeta"></div>
          </div>
          <nav id="toc" class="text-sm space-y-1 max-h-72 overflow-auto pr-1 scrollbar-thin">
            <!-- TOC items injected -->
          </nav>
        </div>
      </section>
    </aside>

    <!-- Right column (Output) -->
    <section class="lg:col-span-9 space-y-4">

      <div class="rounded-2xl glass border shadow-glow" style="border-color: var(--outline);">
        <!-- Toolbar -->
        <div class="px-4 sm:px-5 py-3 border-b flex items-center gap-2" style="border-color: var(--outline);">
          <h3 class="text-sm font-semibold mr-auto">Final Output</h3>

          <!-- removed MD / Mermaid / Citations chips per request -->

          <!-- Variant switcher -->
          <div class="inline-flex items-center mr-2 rounded-xl border p-0.5 bg-[var(--surface)]" role="tablist"
            aria-label="Variant" style="border-color: var(--outline)">
            <button id="variantDetailed" data-variant="detailed"
              class="ripple px-3 py-1.5 rounded-lg text-xs hover:bg-[var(--brand-soft)] transition">Detailed</button>
            <button id="variantCheatsheet" data-variant="cheatsheet"
              class="ripple px-3 py-1.5 rounded-lg text-xs hover:bg-[var(--brand-soft)] transition">Cheat Sheet</button>
            <button id="variantSimple" data-variant="simple"
              class="ripple px-3 py-1.5 rounded-lg text-xs hover:bg-[var(--brand-soft)] transition">Simple</button>
          </div>

          <!-- removed Edit & Copy MD buttons per request -->
          <button id="saveBtn"
            class="ripple px-3 py-2 rounded-lg bg-emerald-500/90 hover:bg-emerald-600 text-white text-sm hidden">Save</button>
          <button id="myNoteBtn" class="ripple px-3 py-2 rounded-lg border text-sm hover:bg-[var(--brand-soft)] hidden"
            style="border-color: var(--outline)">My note</button>
          <button id="editToggle" class="ripple px-3 py-2 rounded-lg border text-sm hover:bg-[var(--brand-soft)]"
            style="border-color: var(--outline)">Edit</button>
          <button id="downloadBtn" class="ripple px-3 py-2 rounded-lg border text-sm hover:bg-[var(--brand-soft)]"
            style="border-color: var(--outline)">Download</button>
          <button id="emphBtn" class="ripple px-3 py-2 rounded-lg border text-sm hover:bg-[var(--brand-soft)]"
            style="border-color: var(--outline)">Emphasis</button>
          <button id="expandBtn" class="ripple px-3 py-2 rounded-lg border text-sm hover:bg-[var(--brand-soft)]"
            style="border-color: var(--outline)">Fullscreen</button>
        </div>

        <!-- Output -->
        <div id="outputWrap" class="relative p-4 sm:p-6">
          <!-- Centered loader overlay inside the answer box -->
          <div id="outputLoader" class="absolute inset-0 z-10 flex items-center justify-center pointer-events-none"
            style="display: none;">
            <div class="px-loader-box">
              <dotlottie-wc src="https://lottie.host/848055f4-11c7-4032-80e0-d51319c33bca/lF6845uqpU.lottie" autoplay
                loop></dotlottie-wc>
            </div>
          </div>
          <article id="output" class="prose prose-slate dark:prose-invert max-w-none"></article>

          <textarea id="editor"
            class="hidden w-full h-[60vh] mt-2 p-3 rounded-lg border font-mono text-[13px] font-semibold"
            style="border-color: var(--outline); background: var(--surface); color: var(--surface-contrast)"
            spellcheck="false"></textarea>

          <!-- Fullscreen overlay controls -->
          <div id="fsControls" class="hidden fixed top-4 right-4 z-[60] flex items-center gap-2">
            <button id="fsExitBtn"
              class="ripple px-3 py-1.5 rounded-lg border text-sm bg-[var(--surface)]/90 hover:bg-[var(--brand-soft)]"
              style="border-color: var(--outline)">Exit Fullscreen</button>
            <button id="fsHomeBtn"
              class="ripple px-3 py-1.5 rounded-lg bg-brand-600 hover:bg-brand-700 text-white text-sm">Home</button>
          </div>
        </div>
      </div>

      <!-- Floating AI Assistant FAB -->
      <button id="aiFab" title="AI Assistant"
        class="ripple fixed bottom-6 right-10 w-14 h-14 rounded-full shadow-neon bg-gradient-to-tr from-fuchsia-500 via-brand-500 to-indigo-500 text-white flex items-center justify-center text-2xl font-semibold hover:scale-105 active:scale-95 transition-transform">
        <span class="material-symbols-outlined">robot_2</span>
      </button>

      <!-- AI Assistant Panel -->
      <div id="aiPanel"
        class="fixed bottom-28 right-6 w-[min(420px,90vw)] max-h-[70vh] flex flex-col rounded-2xl glass border shadow-neon overflow-hidden opacity-0 pointer-events-none translate-y-4 transition-all duration-300"
        style="border-color: var(--outline); backdrop-filter: blur(14px);">
        <div class="flex items-center gap-2 px-4 py-3 border-b" style="border-color: var(--outline);">
          <span class="material-symbols-outlined text-brand-500">robot_2</span>
          <h2 class="text-sm font-semibold">Tune AI</h2>
          <span id="aiAdjustStatus" class="ml-auto text-[11px] text-[var(--muted)] hidden">Processing...</span>
          <button id="aiClosePanel" class="ripple ml-2 px-2 py-1 rounded-md border text-xs hover:bg-[var(--brand-soft)]"
            style="border-color: var(--outline);">
            <span class="material-symbols-outlined text-sm">close</span>
          </button>
        </div>
        <div class="p-4 space-y-3 text-sm overflow-auto custom-scroll">
          <div class="flex flex-wrap gap-2">
            <button id="aiSummarize" class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
              style="border-color: var(--outline)"><span
                class="material-symbols-outlined text-xs align-middle mr-1">compress</span>Summarize</button>
            <button id="aiExpand" class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
              style="border-color: var(--outline)"><span
                class="material-symbols-outlined text-xs align-middle mr-1">unfold_more</span>Expand</button>
            <button id="aiSimplify" class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
              style="border-color: var(--outline)"><span
                class="material-symbols-outlined text-xs align-middle mr-1">lightbulb</span>Simplify</button>
            <button id="aiRevert" class="ripple px-3 py-2 rounded-lg border text-xs bg-[var(--chip)] hidden"
              style="border-color: var(--outline)"><span
                class="material-symbols-outlined text-xs align-middle mr-1">undo</span>Revert</button>
          </div>
          <div>
            <label for="aiCustomPrompt"
              class="block text-[11px] tracking-wide uppercase font-medium mb-1 text-[var(--muted)]">Custom
              Instruction</label>
            <textarea id="aiCustomPrompt" rows="3" placeholder="e.g. Add intuitive analogies without altering equations"
              class="w-full px-3 py-2 rounded-lg border text-sm focus:outline-none focus:ring-2 focus:ring-brand-500/50"
              style="border-color: var(--outline); background: var(--surface); color: var(--surface-contrast);"></textarea>
          </div>
          <div class="flex items-center gap-2">
            <button id="aiCustomApply"
              class="ripple px-4 py-2 rounded-lg bg-brand-600 hover:bg-brand-700 text-white text-xs font-medium tracking-wide">Run</button>
            <button id="aiClearPrompt" class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
              style="border-color: var(--outline)">Clear</button>
            <div class="ml-auto text-[10px] text-[var(--muted)]">Transforms are temporary until saved.</div>
          </div>
          <div class="rounded-lg border p-3 text-[11px] leading-relaxed bg-[var(--chip)]/60"
            style="border-color: var(--outline)">
            <p class="mb-1 font-semibold text-[12px]">Hints</p>
            <ul class="list-disc list-inside space-y-0.5">
              <li>Chain prompts (e.g. "shorten section 2 then add table").</li>
              <li>Use Revert to restore original when first transform began.</li>
              <li>Edits here do not auto-save — click Save in editor.</li>
            </ul>
          </div>
        </div>
      </div>

    </section>
  </main>

  <!-- Snackbar -->
  <div id="snack"
    class="fixed left-1/2 -translate-x-1/2 bottom-4 px-4 py-2 rounded-xl shadow-glow bg-[var(--surface)] border text-sm hidden"
    style="border-color: var(--outline)">Copied</div>

  <!-- Inline Gemini helper affordances -->
  <button id="geminiSelectionBtn" type="button" aria-label="Ask TuneAI about selection"
    class="hidden select-none text-brand-600"
    style="position:absolute; z-index:70; border:1px solid var(--outline); background:var(--surface); border-radius:999px; padding:6px; box-shadow:0 6px 16px rgba(15,23,42,0.18);">
    <span class="material-symbols-outlined text-base leading-none">auto_awesome</span>
  </button>
  <div id="geminiSelectionPanel" role="dialog" aria-modal="false" aria-hidden="true"
    class="hidden rounded-2xl glass border shadow-glow custom-scroll"
    style="position:absolute; z-index:70; width:420px; max-width:calc(100vw-32px); border-color:var(--outline);">
    <div class="p-4 space-y-2">
      <div class="flex items-start justify-between gap-2">
        <div class="flex items-center gap-1.5 text-[12px] font-semibold text-brand-600">
          <span class="material-symbols-outlined text-base leading-none">auto_awesome</span>
          TuneAI Inline
        </div>
        <button id="geminiSelectionClose" type="button"
          class="text-[10px] uppercase tracking-wide text-[var(--muted)] hover:text-[var(--surface-contrast)]">Close</button>
      </div>
      <div
        class="text-[11px] text-[var(--muted)] bg-[var(--chip)]/60 rounded-lg px-2 py-1 max-h-20 overflow-auto custom-scroll"
        id="geminiSelectionContext"></div>
      <label for="geminiSelectionInput" class="text-[11px] font-medium text-[var(--muted)] tracking-wide uppercase">Ask
        anything</label>
      <textarea id="geminiSelectionInput" rows="2" spellcheck="false"
        class="w-full px-3 py-2 rounded-xl border text-sm focus:outline-none focus:ring-2 focus:ring-brand-500/50"
        placeholder="Explain it simply, expand it, translate it..."
        style="border-color:var(--outline); background:var(--surface); color:var(--surface-contrast);"></textarea>
      <div class="flex items-center gap-2">
        <button id="geminiSelectionRun" type="button"
          class="ripple px-3 py-2 rounded-lg bg-brand-600 hover:bg-brand-700 text-white text-xs font-semibold uppercase tracking-wide">Ask
          Tune</button>
        <button id="geminiSelectionMeaning" type="button"
          class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
          style="border-color:var(--outline)"><span
            class="material-symbols-outlined text-xs align-middle mr-1">translate</span>Meaning</button>
        <button id="geminiSelectionEdit" type="button"
          class="ripple px-3 py-2 rounded-lg border text-xs hover:bg-[var(--brand-soft)]"
          style="border-color:var(--outline)"><span
            class="material-symbols-outlined text-xs align-middle mr-1">edit</span>Edit</button>
        <div id="geminiSelectionStatus" class="text-[11px] text-[var(--muted)] hidden"></div>
      </div>
      <div id="geminiSelectionOutput"
        class="text-sm leading-relaxed prose prose-sm dark:prose-invert max-h-56 overflow-auto custom-scroll"></div>
    </div>
  </div>



  <!-- Inject Material Symbols for icons used in the FAB/panel -->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0"
    rel="stylesheet" />

  <style>
    /* Floating AI Assistant panel open state and scrollbars */
    #aiPanel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    #aiPanel::-webkit-scrollbar {
      width: 8px;
    }

    #aiPanel::-webkit-scrollbar-thumb {
      background: var(--outline);
      border-radius: 4px;
    }

    #geminiSelectionBtn {
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    #geminiSelectionBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.25);
    }

    #geminiSelectionPanel {
      backdrop-filter: blur(18px);
    }

    #geminiSelectionOutput :is(p, ul, ol) {
      margin: 0.35rem 0;
      font-size: 0.85rem;
    }

    #geminiSelectionOutput::-webkit-scrollbar {
      width: 6px;
    }

    #geminiSelectionOutput::-webkit-scrollbar-thumb {
      background: var(--outline);
      border-radius: 4px;
    }

    #geminiSelectionContext {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-height: 1.5rem;
    }

    #output ::selection {
      background: #9f4e8d;
      color: #ffffff;
    }

    .custom-scroll::-webkit-scrollbar {
      width: 6px;
    }

    .custom-scroll::-webkit-scrollbar-thumb {
      background: var(--outline);
      border-radius: 4px;
    }
  </style>

  <script>
    // ===== Markdown / Mermaid setup =====
    mermaid.initialize({ startOnLoad: false, theme: 'default' });
    marked.use({ gfm: true, breaks: true, mangle: false, headerIds: true });

    // Central API base (supports file:// open or custom API_BASE)
    let __defaultBase = 'https://paperxapp.onrender.com';
    if (/^https?:/i.test(window.location.origin)) {
      const host = window.location.host;
      if (/localhost:5500|127\.0\.0\.1:5500/.test(host)) {
        __defaultBase = 'https://paperxapp.onrender.com';
      } else {
        __defaultBase = window.location.origin;
      }
    }
    const apiBase = (window.API_BASE || __defaultBase).replace(/\/$/, '');

    // ===== Elements =====
    const $relatedVideosSection = document.getElementById('relatedVideosSection');
    const $relatedVideosSummary = document.getElementById('relatedVideosSummary');
    const $relatedVideosSkeleton = document.getElementById('relatedVideosSkeleton');
    const $relatedVideosWrap = document.getElementById('relatedVideosWrap');
    const $relatedVideosCarousel = document.getElementById('relatedVideoCarousel');
    const $relatedVideosEmpty = document.getElementById('relatedVideosEmpty');
    const $refreshVideos = document.getElementById('refreshVideosBtn');
    const $videoLanguage = document.getElementById('videoLanguageSelect');
    const $topic = document.getElementById('topic');
    const $degree = document.getElementById('degreeSelect');
    const $degreeCustom = document.getElementById('degreeCustom');
    const $degreeCustomRow = document.getElementById('degreeCustomRow');
    const $degreeRow = document.getElementById('degreeRow');
    const $generate = document.getElementById('generateBtn');
    const $regen = document.getElementById('regenBtn');
    const $regenMobile = document.getElementById('regenBtnMobile');
    const $cancel = document.getElementById('cancelBtn');
    const $output = document.getElementById('output');
    const $images = document.getElementById('images');
    const $toc = document.getElementById('toc');
    const $progress = document.getElementById('progressBar');
    const $copy = document.getElementById('copyBtn');
    const $download = document.getElementById('downloadBtn');
    const $emphBtn = document.getElementById('emphBtn');
    const $expand = document.getElementById('expandBtn');
    const $wrap = document.getElementById('outputWrap');
    const $outputLoader = document.getElementById('outputLoader');
    const $editToggle = document.getElementById('editToggle');
    const $save = document.getElementById('saveBtn');
    const $myNoteBtn = document.getElementById('myNoteBtn');
    const $editor = document.getElementById('editor');
    const $meta = document.getElementById('noteMeta');
    const $domainsHint = document.getElementById('domainsHint');
    const $snack = document.getElementById('snack');
    const $themeBtn = document.getElementById('themeBtn');
    const $densityBtn = document.getElementById('densityBtn');
    const $fsCtrl = document.getElementById('fsControls');
    const $fsExit = document.getElementById('fsExitBtn');
    const $fsHome = document.getElementById('fsHomeBtn');
    const $flashcardBtn = document.getElementById('flashcardBtn');
    const $mcqBtn = document.getElementById('mcqBtn');
    const flashcardDefaultLabel = $flashcardBtn ? ($flashcardBtn.textContent || 'Flashcards') : 'Flashcards';
    const mcqDefaultLabel = $mcqBtn ? ($mcqBtn.textContent || 'MCQ') : 'MCQ';
    const $variantDetailed = document.getElementById('variantDetailed');
    const $variantCheatsheet = document.getElementById('variantCheatsheet');
    const $variantSimple = document.getElementById('variantSimple');
    // inline panel action buttons are wired inside the inline IIFE

    const fallbackChannelLogo = 'https://www.youtube.com/s/desktop/94838207/img/favicon_144x144.png';
    const channelLogoCache = new Map();
    let relatedVideosAbort = null;
    let relatedVideosTopic = '';
    let relatedVideosFullQuery = '';
    let relatedVideosLanguage = ($videoLanguage?.value || 'English');
    let relatedVideosDebounce = null;

    // ===== Degree handling =====
    const DEGREE_KEY = 'paperx:degree';
    function getStoredDegree() {
      try { return localStorage.getItem(DEGREE_KEY) || ''; } catch { return ''; }
    }
    function setStoredDegree(v) {
      try { if (v) localStorage.setItem(DEGREE_KEY, v); else localStorage.removeItem(DEGREE_KEY); } catch { }
    }
    function getSelectedDegree() {
      // Prefer hidden select/custom values; fall back to stored degree if UI not initialized yet.
      const uiVal = (() => {
        if (!$degree) return '';
        const v = ($degree.value || '').trim();
        if (v === 'custom') { return ($degreeCustom?.value || '').trim(); }
        return v;
      })();
      if (uiVal) return uiVal;
      const stored = getStoredDegree();
      return (stored || '').trim();
    }
    async function loadDegreeOptions() {
      if (!$degree) return;
      // Preserve any existing non-default options except 'custom'
      try {
        const res = await fetch(`${apiBase}/api/notes/degrees`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const arr = await res.json();
        const selected = getStoredDegree();
        // Reset to default + custom
        $degree.innerHTML = '';
        const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = 'Select degree…'; $degree.appendChild(opt0);
        if (Array.isArray(arr)) {
          arr.forEach(row => {
            const lbl = (row && (row.degree_label || row.degree_key)) || '';
            const key = (row && (row.degree_key || row.degree_label)) || '';
            const val = (lbl || key || '').trim();
            if (!val) return;
            const opt = document.createElement('option');
            opt.value = val; opt.textContent = lbl || key;
            $degree.appendChild(opt);
          });
        }
        const optC = document.createElement('option'); optC.value = 'custom'; optC.textContent = 'Other…'; $degree.appendChild(optC);
        // Apply selection
        if (selected) {
          // If matches an option, select it; else select custom and fill input
          const match = Array.from($degree.options).some(o => (o.value || '').toLowerCase() === selected.toLowerCase());
          if (match) {
            $degree.value = selected;
            $degreeCustomRow?.classList.add('hidden');
          } else {
            $degree.value = 'custom';
            if ($degreeCustom) $degreeCustom.value = selected;
            $degreeCustomRow?.classList.remove('hidden');
          }
        }
        updateDomainsHintDebounced();
      } catch {
        // ignore
      }
    }
    function onDegreeChange() {
      const val = ($degree?.value || '').trim();
      if (val === 'custom') {
        $degreeCustomRow?.classList.remove('hidden'); // keep row hidden globally; used only if we ever show
        // don't store incomplete custom until user types
      } else {
        $degreeCustomRow?.classList.add('hidden');
        setStoredDegree(val);
        updateDomainsHintDebounced();
      }
    }
    function onDegreeCustomInput() {
      const v = ($degreeCustom?.value || '').trim();
      setStoredDegree(v);
      updateDomainsHintDebounced();
    }
    async function updateDomainsHint() {
      if (!$domainsHint) return;
      const degree = getSelectedDegree();
      if (!degree) { $domainsHint.textContent = 'Sources: auto'; return; }
      try {
        const res = await fetch(`${apiBase}/api/notes/allowed-domains?degree=${encodeURIComponent(degree)}`);
        if (!res.ok) { $domainsHint.textContent = `Degree: ${degree}`; return; }
        const data = await res.json();
        const list = (data && Array.isArray(data.domains)) ? data.domains : [];
        if (!list || list.length === 0) { $domainsHint.textContent = `Degree: ${degree} • web (fallback)`; return; }
        const preview = list.slice(0, 4).join(', ');
        $domainsHint.textContent = `Degree: ${degree} • ${preview}${list.length > 4 ? '…' : ''}`;
      } catch {
        $domainsHint.textContent = `Degree: ${degree}`;
      }
    }
    let domainsHintTimer = null;
    function updateDomainsHintDebounced() {
      if (domainsHintTimer) clearTimeout(domainsHintTimer);
      domainsHintTimer = setTimeout(updateDomainsHint, 250);
    }

    // Auto-resolve degree from logged-in profile and hide UI controls
    async function autoResolveDegreeFromProfile() {
      try {
        const token = getAuthToken();
        if (!token) { return false; }
        const meRes = await fetch(`${apiBase}/api/me`, { headers: { Authorization: `Bearer ${token}` } });
        if (!meRes.ok) { return false; }
        const me = await meRes.json();
        const deptId = me && me.profile && me.profile.department && me.profile.department.id;
        if (!deptId) { return false; }
        // fetch academic meta to map department -> degree
        const metaRes = await fetch(`${apiBase}/api/public/academic-meta`);
        if (!metaRes.ok) { return false; }
        const meta = await metaRes.json();
        const depts = Array.isArray(meta && meta.departments) ? meta.departments : [];
        const degrees = Array.isArray(meta && meta.degrees) ? meta.degrees : [];
        const dept = depts.find(d => String(d.id) === String(deptId));
        if (!dept || !dept.degree_id) { return false; }
        const deg = degrees.find(g => String(g.id) === String(dept.degree_id));
        const label = (deg && deg.name) ? String(deg.name).trim() : '';
        if (!label) { return false; }
        // Store and set hidden inputs
        setStoredDegree(label);
        if ($degree) {
          // Try to select matching option if present, else set custom value
          const match = Array.from($degree.options || []).some(o => (o.value || '').toLowerCase() === label.toLowerCase());
          if (match) { $degree.value = label; }
          else { $degree.value = 'custom'; if ($degreeCustom) $degreeCustom.value = label; }
        }
        updateDomainsHintDebounced();
        return true;
      } catch { return false; }
    }

    function normalizeVideoLanguage(language) {
      return (language || '').trim();
    }

    function buildRelatedVideosQuery(baseTopic, language) {
      const topic = (baseTopic || '').trim();
      if (!topic) return '';
      const lang = normalizeVideoLanguage(language);
      if (!lang) return topic;
      if (lang.toLowerCase() === 'english') return topic;
      const suffix = ` in ${lang}`;
      if (topic.toLowerCase().endsWith(suffix.toLowerCase())) {
        return topic;
      }
      return `${topic}${suffix}`;
    }

    function resetFlashcardAccess() {
      if (!$flashcardBtn) return;
      $flashcardBtn.classList.add('hidden');
      $flashcardBtn.disabled = true;
      $flashcardBtn.setAttribute('aria-disabled', 'true');
      $flashcardBtn.dataset.noteId = '';
      $flashcardBtn.dataset.topic = '';
      $flashcardBtn.classList.remove('pointer-events-none', 'opacity-70');
      if (flashcardDefaultLabel) {
        $flashcardBtn.textContent = flashcardDefaultLabel;
      }
    }

    function resetMCQAccess() {
      if (!$mcqBtn) return;
      $mcqBtn.classList.add('hidden');
      $mcqBtn.disabled = true;
      $mcqBtn.setAttribute('aria-disabled', 'true');
      $mcqBtn.dataset.noteId = '';
      $mcqBtn.dataset.topic = '';
      $mcqBtn.classList.remove('pointer-events-none', 'opacity-70');
      if (mcqDefaultLabel) {
        $mcqBtn.textContent = mcqDefaultLabel;
      }
    }

    function enableFlashcardAccess(noteId, topic) {
      if (!$flashcardBtn) return;
      $flashcardBtn.dataset.noteId = noteId || '';
      $flashcardBtn.dataset.topic = topic || '';
      $flashcardBtn.disabled = false;
      $flashcardBtn.removeAttribute('aria-disabled');
      $flashcardBtn.classList.remove('hidden');
      $flashcardBtn.classList.remove('pointer-events-none', 'opacity-70');
      if (flashcardDefaultLabel) {
        $flashcardBtn.textContent = flashcardDefaultLabel;
      }
    }

    function enableMCQAccess(noteId, topic) {
      if (!$mcqBtn) return;
      $mcqBtn.dataset.noteId = noteId || '';
      $mcqBtn.dataset.topic = topic || '';
      $mcqBtn.disabled = false;
      $mcqBtn.removeAttribute('aria-disabled');
      $mcqBtn.classList.remove('hidden');
      $mcqBtn.classList.remove('pointer-events-none', 'opacity-70');
      if (mcqDefaultLabel) {
        $mcqBtn.textContent = mcqDefaultLabel;
      }
    }

    function openFlashcards() {
      if (!$flashcardBtn) return;
      const noteId = ($flashcardBtn.dataset.noteId || '').trim();
      if (!noteId) {
        snack('Generate notes first');
        return;
      }
      const inferredTopic = (
        ($flashcardBtn.dataset.topic || '')
        || (document.querySelector('#output h1')?.textContent || '')
        || ($topic.value || '')
      ).trim();
      try {
        sessionStorage.setItem('paperx:lastFlashcardSeed', JSON.stringify({ noteId, topic: inferredTopic, ts: Date.now() }));
      } catch (e) { /* ignore */ }
      const search = new URLSearchParams({ noteId });
      if (inferredTopic) {
        search.set('topic', inferredTopic);
      }
      const target = `./flashcards.html?${search.toString()}`;
      $flashcardBtn.classList.add('pointer-events-none', 'opacity-70');
      $flashcardBtn.textContent = 'Opening…';
      setTimeout(() => { window.location.href = target; }, 120);
    }

    function openMCQ() {
      if (!$mcqBtn) return;
      const noteId = ($mcqBtn.dataset.noteId || '').trim();
      if (!noteId) {
        snack('Generate notes first');
        return;
      }
      const inferredTopic = (
        ($mcqBtn.dataset.topic || '')
        || (document.querySelector('#output h1')?.textContent || '')
        || ($topic.value || '')
      ).trim();
      try {
        sessionStorage.setItem('paperx:lastMCQSeed', JSON.stringify({ noteId, topic: inferredTopic, ts: Date.now() }));
      } catch (e) { }
      const search = new URLSearchParams({ noteId });
      if (inferredTopic) search.set('topic', inferredTopic);
      const target = `./mcq.html?${search.toString()}`;
      $mcqBtn.classList.add('pointer-events-none', 'opacity-70');
      $mcqBtn.textContent = 'Opening…';
      setTimeout(() => { window.location.href = target; }, 120);
    }

    resetFlashcardAccess();
    resetMCQAccess();

    // ===== User auth token helper =====
    function getAuthToken() {
      try {
        return localStorage.getItem('teacherToken') || localStorage.getItem('px_token') || '';
      } catch { return ''; }
    }

    // ===== My note visibility and loading =====
    async function checkMyNoteVisibility() {
      if (!$myNoteBtn) return;
      const token = getAuthToken();
      if (!token) { $myNoteBtn.classList.add('hidden'); return; }
      const title = (document.querySelector('#output h1')?.textContent || $topic.value || '').trim();
      if (!title) { $myNoteBtn.classList.add('hidden'); return; }
      try {
        const url = `${apiBase}/api/notes/edited/check?title=${encodeURIComponent(title)}&variant=${encodeURIComponent(currentVariant)}`;
        const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
        if (!res.ok) { $myNoteBtn.classList.add('hidden'); return; }
        const data = await res.json().catch(() => ({}));
        if (data && data.exists) { $myNoteBtn.classList.remove('hidden'); }
        else { $myNoteBtn.classList.add('hidden'); }
      } catch { $myNoteBtn.classList.add('hidden'); }
    }

    // ===== Inline Gemini selection assistant =====
    (function () {
      if (!$output) return;
      const btn = document.getElementById('geminiSelectionBtn');
      const panel = document.getElementById('geminiSelectionPanel');
      const closeBtn = document.getElementById('geminiSelectionClose');
      const promptInput = document.getElementById('geminiSelectionInput');
      const runBtn = document.getElementById('geminiSelectionRun');
      const meaningBtn = document.getElementById('geminiSelectionMeaning');
      const editBtn = document.getElementById('geminiSelectionEdit');
      const statusBox = document.getElementById('geminiSelectionStatus');
      const contextBox = document.getElementById('geminiSelectionContext');
      const outputBox = document.getElementById('geminiSelectionOutput');
      if (!btn || !panel || !runBtn || !contextBox || !outputBox) return;

      const endpoint = `${apiBase}/api/notes/snippet-assist`;
      const MAX_SELECTION_PAYLOAD = 2800;
      const PREVIEW_MAX = 420;
      let selectionText = '';
      let selectionRect = null;
      let selectionEndRect = null;
      let selectionAnchorNode = null;
      let selectionFocusNode = null;
      let panelPinned = false;
      let busy = false;

      function withinOutput(node) {
        if (!node) return false;
        if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;
        return node ? $output.contains(node) : false;
      }

      function hideBtn() {
        btn.classList.add('hidden');
      }

      function resetStatus() {
        if (statusBox) {
          statusBox.textContent = '';
          statusBox.classList.add('hidden');
          delete statusBox.dataset.error;
          statusBox.style.color = 'var(--muted)';
        }
      }

      function setStatus(msg, isError = false) {
        if (!statusBox) return;
        if (!msg) {
          resetStatus();
          return;
        }
        statusBox.textContent = msg;
        statusBox.style.color = isError ? '#ef4444' : 'var(--muted)';
        statusBox.dataset.error = isError ? '1' : '';
        statusBox.classList.remove('hidden');
      }

      function setBusy(state) {
        busy = state;
        runBtn.disabled = state;
        runBtn.classList.toggle('opacity-60', state);
        if (state) {
          setStatus('Asking TuneAI…', false);
        } else if (!statusBox?.dataset.error) {
          resetStatus();
        }
      }

      function captureRect(range) {
        if (!range) return null;
        const rect = range.getBoundingClientRect();
        if (!rect || (!rect.width && !rect.height)) return null;
        return {
          top: rect.top + window.scrollY,
          left: rect.left + window.scrollX,
          right: rect.right + window.scrollX,
          bottom: rect.bottom + window.scrollY,
          width: rect.width || 0,
        };
      }

      function positionBtn(rect) {
        if (!rect) return;
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight;
        const anchorX = (typeof rect.right === 'number' && rect.right) ? rect.right : (rect.left + (rect.width || 0));
        const btnWidth = 32;
        const left = Math.min(
          Math.max(anchorX - btnWidth / 2, window.scrollX + 12),
          window.scrollX + viewportWidth - btnWidth - 12
        );
        const anchorY = (typeof rect.bottom === 'number' && rect.bottom) ? rect.bottom : rect.top;
        const top = Math.min(
          Math.max(anchorY + 6, window.scrollY + 12),
          window.scrollY + viewportHeight - 48
        );
        btn.style.left = `${left}px`;
        btn.style.top = `${top}px`;
        btn.classList.remove('hidden');
      }

      function positionPanel() {
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight;
        const panelWidth = panel.offsetWidth || Math.min(420, viewportWidth - 32);
        let left = selectionRect ? selectionRect.left : (window.scrollX + (viewportWidth - panelWidth) / 2);
        let top = selectionRect ? selectionRect.bottom + 12 : (window.scrollY + 80);
        left = Math.min(Math.max(window.scrollX + 16, left), window.scrollX + viewportWidth - panelWidth - 16);
        const maxTop = window.scrollY + viewportHeight - panel.offsetHeight - 16;
        top = Math.min(Math.max(window.scrollY + 16, top), Number.isFinite(maxTop) ? maxTop : top);
        panel.style.left = `${left}px`;
        panel.style.top = `${top}px`;
      }

      function hidePanel() {
        panelPinned = false;
        panel.classList.add('hidden');
        panel.setAttribute('aria-hidden', 'true');
        resetStatus();
      }

      function updateContextPreview() {
        if (!contextBox) return;
        if (!selectionText) {
          contextBox.textContent = 'Select text in the Final Output to get inline Gemini help.';
          return;
        }
        const preview = selectionText.slice(0, PREVIEW_MAX);
        contextBox.textContent = preview + (selectionText.length > PREVIEW_MAX ? '…' : '');
      }

      function handleSelectionChange() {
        if (panelPinned) return;
        const sel = window.getSelection();
        if (!sel || sel.isCollapsed) {
          selectionText = '';
          selectionRect = null;
          selectionEndRect = null;
          selectionAnchorNode = null;
          selectionFocusNode = null;
          hideBtn();
          return;
        }
        if (!withinOutput(sel.anchorNode) || !withinOutput(sel.focusNode)) {
          selectionText = '';
          selectionRect = null;
          selectionEndRect = null;
          selectionAnchorNode = null;
          selectionFocusNode = null;
          hideBtn();
          return;
        }
        const text = sel.toString().trim();
        if (!text) {
          selectionText = '';
          selectionRect = null;
          selectionEndRect = null;
          selectionAnchorNode = null;
          selectionFocusNode = null;
          hideBtn();
          return;
        }
        selectionText = text.replace(/\s+/g, ' ').trim();
        selectionAnchorNode = sel.anchorNode;
        selectionFocusNode = sel.focusNode;
        const range = sel.getRangeAt(sel.rangeCount - 1);
        const rect = captureRect(range);
        const endClone = range.cloneRange();
        endClone.collapse(false);
        const endRect = captureRect(endClone);
        if (!rect) {
          selectionRect = null;
          selectionEndRect = null;
          hideBtn();
          return;
        }
        selectionRect = rect;
        selectionEndRect = endRect || rect;
        updateContextPreview();
        positionBtn(selectionEndRect);
      }

      async function runGemini() {
        if (!selectionText || !selectionRect) {
          snack('Select some text in the Final Output first');
          return;
        }
        if (busy) return;
        const instruction = (promptInput?.value || '').trim() || 'Explain the highlighted text simply.';
        const payloadSelection = selectionText.slice(0, MAX_SELECTION_PAYLOAD);
        setBusy(true);
        outputBox.innerHTML = '';
        try {
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ selection: payloadSelection, instruction })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            const detail = (data && (data.detail || data.error)) || `HTTP ${res.status}`;
            throw new Error(detail);
          }
          const text = (data && data.text) ? String(data.text) : '';
          if (!text) {
            setStatus('Gemini returned an empty reply', true);
            outputBox.textContent = '';
            return;
          }
          try {
            outputBox.innerHTML = marked.parse(text);
          } catch (err) {
            console.warn('Gemini inline render fallback', err);
            outputBox.textContent = text;
          }

          // Track Note Generation
          if (window.Analytics) {
            window.Analytics.track('note_viewed', {
              variant: 'generated',
              prompt: instruction.slice(0, 50)
            });
          }

          resetStatus();
        } catch (error) {
          console.error('Gemini inline assist error', error);
          setStatus(error?.message || 'Gemini request failed', true);
        } finally {
          setBusy(false);
        }
      }

      async function runMeaning() {
        if (!selectionText || !selectionRect) {
          snack('Select a term or phrase');
          return;
        }
        if (busy) return;
        const instruction = `Give a very short dictionary-like meaning for: "${selectionText}" (1–2 lines). No examples.`;
        const payloadSelection = selectionText.slice(0, MAX_SELECTION_PAYLOAD);
        setBusy(true);
        outputBox.innerHTML = '';
        try {
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ selection: payloadSelection, instruction })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            const detail = (data && (data.detail || data.error)) || `HTTP ${res.status}`;
            throw new Error(detail);
          }
          const text = (data && data.text) ? String(data.text) : '';
          if (!text) {
            setStatus('No meaning available', true);
            outputBox.textContent = '';
            return;
          }
          try {
            outputBox.innerHTML = marked.parse(text);
          } catch {
            outputBox.textContent = text;
          }
          // Ensure panel is visible/pinned near selection
          panelPinned = true;
          panel.classList.remove('hidden');
          panel.setAttribute('aria-hidden', 'false');
          updateContextPreview();
          requestAnimationFrame(positionPanel);
          resetStatus();
        } catch (error) {
          console.warn('Meaning error', error);
          setStatus(error?.message || 'Meaning failed', true);
        } finally {
          setBusy(false);
        }
      }

      function openPanel() {
        if (!selectionText) {
          snack('Select some text in the Final Output first');
          panelPinned = false;
          return;
        }
        panelPinned = true;
        btn.classList.add('hidden');
        panel.classList.remove('hidden');
        panel.setAttribute('aria-hidden', 'false');
        updateContextPreview();
        resetStatus();
        outputBox.innerHTML = '';
        if (promptInput) {
          promptInput.value = promptInput.value.trim() ? promptInput.value : 'Explain it simply';
        }
        requestAnimationFrame(() => {
          positionPanel();
          promptInput?.focus();
        });
      }

      btn.addEventListener('click', openPanel);
      runBtn.addEventListener('click', runGemini);
      promptInput?.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
          e.preventDefault();
          runGemini();
        }
      });
      closeBtn?.addEventListener('click', hidePanel);

      document.addEventListener('selectionchange', () => {
        if (!panelPinned) handleSelectionChange();
      });
      window.addEventListener('scroll', () => {
        if (!panelPinned) hideBtn();
      }, { passive: true });
      window.addEventListener('resize', () => {
        if (panelPinned) {
          requestAnimationFrame(positionPanel);
        } else {
          hideBtn();
        }
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !panel.classList.contains('hidden')) {
          hidePanel();
        }
      });
      document.addEventListener('click', (e) => {
        if (panel.classList.contains('hidden')) return;
        const target = e.target;
        if (panel.contains(target) || btn.contains(target)) return;
        if (withinOutput(target)) return;
        hidePanel();
      });

      updateContextPreview();

      // Inline panel actions: Meaning and Edit
      meaningBtn?.addEventListener('click', runMeaning);
      function findClosestHeadingInOutput(node) {
        if (!node) return null;
        if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;
        let cur = node;
        while (cur && cur !== $output) {
          if (/^H[1-3]$/.test(cur.nodeName)) {
            const level = cur.nodeName === 'H1' ? 1 : (cur.nodeName === 'H2' ? 2 : 3);
            const title = (cur.textContent || '').trim();
            return { level, title };
          }
          cur = cur.previousSibling || cur.parentNode;
        }
        // fallback: search previous headings
        const hs = Array.from($output.querySelectorAll('h1,h2,h3'));
        let last = null;
        for (const h of hs) { if (h.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_FOLLOWING) break; last = h; }
        if (last) {
          const level = last.nodeName === 'H1' ? 1 : (last.nodeName === 'H2' ? 2 : 3);
          return { level, title: (last.textContent || '').trim() };
        }
        return null;
      }

      function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

      function sliceSectionFromMarkdown(md, heading, level) {
        const lines = md.split(/\n/);
        const needle = `${'#'.repeat(level)} ${heading}`;
        const startRe = new RegExp(`^${escapeRegex(needle)}\s*$`, 'i');
        let start = -1;
        for (let i = 0; i < lines.length; i++) { if (startRe.test(lines[i])) { start = i; break; } }
        if (start === -1) return null;
        const stopRe = new RegExp(`^#{1,${level}}\s+`); // next same or higher heading
        let end = lines.length;
        for (let i = start + 1; i < lines.length; i++) { if (stopRe.test(lines[i])) { end = i; break; } }
        const before = lines.slice(0, start).join('\n');
        const section = lines.slice(start, end).join('\n');
        const after = lines.slice(end).join('\n');
        return { before, section, after };
      }

      // --- Inline selection mapping helpers (DOM selection -> markdown substring) ---
      function _normalizeForMatch(s) { return (s || '').replace(/\s+/g, ' ').trim().toLowerCase(); }

      function _buildNormalizedMap(src) {
        const map = [];
        let norm = '';
        let lastSpace = false;
        for (let i = 0; i < src.length; i++) {
          const ch = src[i];
          if (/\s/.test(ch)) {
            if (!lastSpace) { norm += ' '; map.push(i); lastSpace = true; }
          } else { norm += ch.toLowerCase(); map.push(i); lastSpace = false; }
        }
        let a = 0; while (a < norm.length && norm[a] === ' ') a++;
        let b = norm.length; while (b > a && norm[b - 1] === ' ') b--;
        return { norm: norm.slice(a, b), map: map.slice(a, b) };
      }

      function findSelectionInMarkdownSection(sectionMd, selectionTxt) {
        if (!selectionTxt) return null;
        // 1. Direct substring
        let direct = sectionMd.indexOf(selectionTxt);
        if (direct !== -1) return { start: direct, end: direct + selectionTxt.length };
        // 2. Normalized substring
        const { norm, map } = _buildNormalizedMap(sectionMd);
        const sel = _normalizeForMatch(selectionTxt);
        let idx = norm.indexOf(sel);
        if (idx !== -1) {
          const start = map[idx];
          const end = map[Math.min(idx + sel.length - 1, map.length - 1)] + 1;
          return { start, end };
        }
        // 3. Try joining lines in selection (for multi-line or list selections)
        const selFlat = _normalizeForMatch(selectionTxt.replace(/\n+/g, ' '));
        idx = norm.indexOf(selFlat);
        if (idx !== -1) {
          const start = map[idx];
          const end = map[Math.min(idx + selFlat.length - 1, map.length - 1)] + 1;
          return { start, end };
        }
        // 4. Fuzzy: try to find the largest matching substring (at least 10 chars)
        for (let len = Math.min(sel.length, 60); len >= 10; len--) {
          for (let i = 0; i <= sel.length - len; i++) {
            const sub = sel.slice(i, i + len);
            const subIdx = norm.indexOf(sub);
            if (subIdx !== -1) {
              const start = map[subIdx];
              const end = map[Math.min(subIdx + len - 1, map.length - 1)] + 1;
              return { start, end, partial: true };
            }
          }
        }
        return null;
      }

      function isWithinCodeOrPre(node) {
        if (!node) return false;
        if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;
        const pre = node.closest ? node.closest('pre, code') : null;
        return !!pre;
      }

      async function persistMyNote(fullMarkdown) {
        const token = getAuthToken();
        if (!token) return false;
        const title = (document.querySelector('#output h1')?.textContent || $topic.value || 'Untitled').trim();
        if (!title) return false;
        try {
          const res = await fetch(`${apiBase}/api/notes/edited?variant=${encodeURIComponent(currentVariant)}`, {
            method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
            body: JSON.stringify({ title, markdown: fullMarkdown })
          });
          if (!res.ok) return false;
          return true;
        } catch { return false; }
      }

      editBtn?.addEventListener('click', async () => {
        const anchor = selectionAnchorNode;
        const focus = selectionFocusNode;
        if (!selectionText || (!anchor && !focus)) { snack('Select text to edit'); return; }
        if (isWithinCodeOrPre(anchor) || isWithinCodeOrPre(focus)) { snack('Inline edit works on regular text (not code blocks)'); return; }
        const head = findClosestHeadingInOutput(anchor) || findClosestHeadingInOutput(focus);
        if (!head || head.level === 1) { snack('Place cursor inside a section (H2/H3)'); return; }
        const found = sliceSectionFromMarkdown(lastMarkdown || '', head.title, head.level);
        if (!found || !found.section) { snack('Could not locate section in markdown'); return; }
        const match = findSelectionInMarkdownSection(found.section, selectionText);
        let selectedMd, replaceStart, replaceEnd, partial = false;
        if (match) {
          selectedMd = found.section.slice(match.start, match.end);
          replaceStart = match.start;
          replaceEnd = match.end;
          partial = !!match.partial;
        } else {
          // Fallback: try to find the paragraph or list item containing the selection
          const paras = found.section.split(/\n{2,}/);
          let paraIdx = -1;
          for (let i = 0; i < paras.length; i++) {
            if (_normalizeForMatch(paras[i]).includes(_normalizeForMatch(selectionText))) { paraIdx = i; break; }
          }
          if (paraIdx !== -1) {
            let offset = 0;
            for (let j = 0; j < paraIdx; j++) offset += paras[j].length + 2;
            selectedMd = paras[paraIdx];
            replaceStart = offset;
            replaceEnd = offset + paras[paraIdx].length;
            partial = true;
          } else {
            snack('Could not map selection to markdown. Try a shorter or more precise phrase.');
            return;
          }
        }
        const instruction = (promptInput?.value || '').trim() || (partial ? 'edit this part for clarity' : 'simplify the selected text with clearer language');
        try {
          setStatus('Processing…'); setBusy(true);
          const res = await fetch(`${apiBase}/api/notes/transform`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: 'custom', markdown: selectedMd, prompt: instruction })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error((data && (data.detail || data.error)) || 'Transform failed');
          const replacement = (data && data.markdown) ? String(data.markdown) : '';
          if (!replacement) { snack('No change'); return; }
          const updatedSection = found.section.slice(0, replaceStart) + replacement + found.section.slice(replaceEnd);
          const merged = [found.before, updatedSection, found.after].filter(Boolean).join('\n');
          lastMarkdown = merged;
          if ($editor && !$editor.classList.contains('hidden')) { $editor.value = merged; }
          renderMarkdown(merged);
          const ok = await persistMyNote(merged);
          if (ok) { snack('Edited and saved to My note'); checkMyNoteVisibility(); } else { snack('Edited (not saved — sign in to save)'); }
        } catch (e) { console.warn('Edit selection error', e); snack('Edit failed'); }
        finally { setBusy(false); resetStatus(); }
      });
    })();

    function getChannelLogoAsync(channelPage) {
      if (!channelPage) return Promise.resolve('');
      const cached = channelLogoCache.get(channelPage);
      if (cached !== undefined) {
        return cached instanceof Promise ? cached : Promise.resolve(cached);
      }
      const request = (async () => {
        try {
          const res = await fetch(`${apiBase}/api/youtube/channel-logo?channel_url=${encodeURIComponent(channelPage)}`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          const logo = typeof data.logo === 'string' ? data.logo.trim() : '';
          channelLogoCache.set(channelPage, logo);
          return logo;
        } catch (error) {
          console.warn('Channel logo lookup failed:', error);
          channelLogoCache.set(channelPage, '');
          return '';
        }
      })();
      channelLogoCache.set(channelPage, request);
      return request;
    }

    function hydrateChannelLogo(img, channelPage, shouldAttempt) {
      if (!img) return;
      if (channelPage) {
        img.dataset.channelPage = channelPage;
      }
      if (!shouldAttempt || !channelPage) {
        return;
      }
      getChannelLogoAsync(channelPage)
        .then((logo) => {
          if (logo && img.dataset.channelPage === channelPage) {
            img.src = logo;
            img.dataset.logoLoaded = 'true';
          }
        })
        .catch(() => { /* already logged */ });
    }

    function createRelatedVideoCard(video) {
      const card = document.createElement('div');
      const link = (typeof video.link === 'string' && video.link.trim()) || '';
      const notesUrl = link ? `./youtube-notes.html?video=${encodeURIComponent(link)}` : '';
      card.className = 'yt-card';
      card.setAttribute('data-video-card', '1');

      const thumb = document.createElement('div');
      thumb.className = 'yt-thumb';
      const thumbImg = document.createElement('img');
      const videoId = typeof video.id === 'string' ? video.id.trim() : '';
      const thumbSrc = (typeof video.thumbnail === 'string' && video.thumbnail.trim())
        || (videoId ? `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg` : '');
      thumbImg.src = thumbSrc || fallbackChannelLogo;
      thumbImg.alt = (video.title || 'YouTube video').toString();
      thumbImg.loading = 'lazy';
      thumbImg.decoding = 'async';
      thumb.appendChild(thumbImg);
      if (video.duration) {
        const badge = document.createElement('span');
        badge.className = 'yt-duration';
        badge.textContent = video.duration;
        thumb.appendChild(badge);
      }
      if (video.recommended) {
        const recBadge = document.createElement('span');
        // Solid brand background so it remains clearly visible
        recBadge.className = 'absolute left-2 top-2 z-[1] inline-flex items-center gap-1 rounded-full bg-brand-600 px-3 py-1.5 text-[11px] font-semibold uppercase tracking-wide text-white shadow-[0_10px_26px_rgba(15,23,42,0.45)]';
        const star = document.createElement('span');
        star.className = 'text-[15px] leading-none';
        star.style.color = '#FBBF24';
        star.textContent = '\u2605';
        const label = document.createElement('span');
        label.textContent = 'Recommended';
        recBadge.appendChild(star);
        recBadge.appendChild(label);
        thumb.appendChild(recBadge);
      }
      card.appendChild(thumb);

      const body = document.createElement('div');
      body.className = 'yt-body';

      const titleEl = document.createElement('p');
      titleEl.className = 'yt-title';
      const titleText = (typeof video.title === 'string' ? video.title : '').trim() || 'Untitled video';
      titleEl.textContent = titleText;
      titleEl.title = titleText;
      body.appendChild(titleEl);

      const meta = document.createElement('div');
      meta.className = 'yt-meta';

      const logoImg = document.createElement('img');
      logoImg.className = 'yt-channel-logo';
      logoImg.src = (typeof video.channel_logo === 'string' && video.channel_logo.trim()) || fallbackChannelLogo;
      logoImg.alt = (video.channel || 'Channel').toString();
      logoImg.loading = 'lazy';
      logoImg.referrerPolicy = 'no-referrer';
      meta.appendChild(logoImg);

      const channelName = document.createElement('span');
      channelName.className = 'yt-channel-name';
      channelName.textContent = (video.channel || 'YouTube').toString();
      meta.appendChild(channelName);

      if (video.views) {
        const views = document.createElement('span');
        views.className = 'yt-views';
        views.textContent = video.views;
        meta.appendChild(views);
      }

      body.appendChild(meta);
      card.appendChild(body);

      // Add a soft brand-colored glow for recommended videos
      if (video.recommended) {
        card.classList.add('shadow-[0_0_0_1px_rgba(158,75,138,0.4)]', 'shadow-neon');
      }

      const channelPage = (typeof video.channel_page === 'string' ? video.channel_page : '').trim();
      const logoIsDefault = Boolean(video.channel_logo_is_default) || !video.channel_logo || video.channel_logo === fallbackChannelLogo;
      hydrateChannelLogo(logoImg, channelPage, logoIsDefault && !!channelPage);

      const overlay = document.createElement('div');
      overlay.className = 'yt-hover-overlay';

      const playBtn = document.createElement('button');
      playBtn.type = 'button';
      playBtn.className = 'yt-hover-btn yt-hover-btn-play';
      playBtn.setAttribute('aria-label', 'Play on YouTube');
      playBtn.title = 'Play on YouTube';
      const playIcon = document.createElement('span');
      playIcon.className = 'yt-hover-btn-icon';
      playIcon.textContent = 'play_arrow';
      playBtn.appendChild(playIcon);
      if (!link) {
        playBtn.disabled = true;
        playBtn.style.opacity = '0.6';
        playBtn.style.cursor = 'not-allowed';
      }
      playBtn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (link) {
          window.open(link, '_blank', 'noopener');
        }
      });

      const notesBtn = document.createElement('button');
      notesBtn.type = 'button';
      notesBtn.className = 'yt-hover-btn yt-hover-btn-notes';
      notesBtn.setAttribute('aria-label', 'Open PaperX notes');
      notesBtn.title = 'Open PaperX notes';
      const notesIcon = document.createElement('span');
      notesIcon.className = 'yt-hover-btn-icon';
      notesIcon.textContent = 'description';
      notesBtn.appendChild(notesIcon);
      if (!notesUrl || notesUrl === '#') {
        notesBtn.disabled = true;
        notesBtn.style.opacity = '0.6';
        notesBtn.style.cursor = 'not-allowed';
      }
      notesBtn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (notesUrl && notesUrl !== '#') {
          window.open(notesUrl, '_blank', 'noopener');
        }
      });

      overlay.appendChild(playBtn);
      overlay.appendChild(notesBtn);

      thumb.appendChild(overlay);
      return card;
    }

    function renderRelatedVideos(videos, displayTopic, baseTopic, language) {
      if (!$relatedVideosWrap || !$relatedVideosCarousel) return;
      $relatedVideosCarousel.innerHTML = '';
      const fragment = document.createDocumentFragment();
      videos.forEach(video => fragment.appendChild(createRelatedVideoCard(video)));
      $relatedVideosCarousel.appendChild(fragment);
      $relatedVideosSkeleton?.classList.add('hidden');
      $relatedVideosEmpty?.classList.add('hidden');
      $relatedVideosWrap.classList.remove('hidden');
      if ($relatedVideosSummary) {
        $relatedVideosSummary.textContent = `Showing for "${displayTopic}"`;
      }
      try {
        localStorage.setItem('paperx:lastVideos', JSON.stringify(videos));
        if (baseTopic) {
          localStorage.setItem('paperx:lastTopic', baseTopic);
        } else {
          localStorage.removeItem('paperx:lastTopic');
        }
        if (language) {
          localStorage.setItem('paperx:lastVideoLanguage', language);
        } else {
          localStorage.removeItem('paperx:lastVideoLanguage');
        }
      } catch { }
    }

    async function loadRelatedVideos(topic, options = {}) {
      const baseQuery = (topic || '').trim();
      const force = Boolean(options.force);
      const requestedLanguage = normalizeVideoLanguage(options.language ?? relatedVideosLanguage);
      const searchQuery = buildRelatedVideosQuery(baseQuery, requestedLanguage);

      if (!baseQuery) {
        relatedVideosTopic = '';
        relatedVideosFullQuery = '';
        relatedVideosAbort?.abort();
        relatedVideosAbort = null;
        if ($relatedVideosSection) $relatedVideosSection.classList.remove('hidden');
        if ($relatedVideosSummary) {
          $relatedVideosSummary.textContent = 'Enter a topic to discover supporting videos.';
        }
        if ($relatedVideosCarousel) $relatedVideosCarousel.innerHTML = '';
        $relatedVideosSkeleton?.classList.add('hidden');
        if ($relatedVideosEmpty) {
          $relatedVideosEmpty.textContent = 'Videos will appear once a topic is generated.';
          $relatedVideosEmpty.classList.remove('hidden');
        }
        try {
          localStorage.removeItem('paperx:lastTopic');
          localStorage.removeItem('paperx:lastVideos');
          localStorage.removeItem('paperx:lastVideoLanguage');
        } catch { }
        return;
      }

      if (!force && relatedVideosFullQuery && relatedVideosFullQuery.toLowerCase() === searchQuery.toLowerCase()) {
        return;
      }

      relatedVideosTopic = baseQuery;
      relatedVideosLanguage = requestedLanguage || 'English';
      relatedVideosFullQuery = searchQuery;
      if ($relatedVideosSection) $relatedVideosSection.classList.remove('hidden');
      if ($relatedVideosSummary) {
        $relatedVideosSummary.textContent = `Finding videos for "${searchQuery}"...`;
      }
      try {
        localStorage.setItem('paperx:lastTopic', baseQuery);
        if (relatedVideosLanguage) {
          localStorage.setItem('paperx:lastVideoLanguage', relatedVideosLanguage);
        }
      } catch { }

      if (relatedVideosAbort) {
        relatedVideosAbort.abort();
      }
      relatedVideosAbort = typeof AbortController !== 'undefined' ? new AbortController() : null;

      const hasExisting = $relatedVideosCarousel && $relatedVideosCarousel.children.length > 0;
      if (hasExisting) {
        $relatedVideosSkeleton?.classList.add('hidden');
        $relatedVideosWrap?.classList.remove('hidden');
      } else {
        $relatedVideosSkeleton?.classList.remove('hidden');
        $relatedVideosWrap?.classList.add('hidden');
      }
      $relatedVideosEmpty?.classList.add('hidden');

      try {
        // First, try to fetch a syllabus-linked video_url for this topic
        let recommended = null;
        try {
          const recRes = await fetch(`${apiBase}/api/syllabus/topics/by-title?topic=${encodeURIComponent(baseQuery)}`);
          if (recRes.ok) {
            const recData = await recRes.json();
            if (Array.isArray(recData) && recData.length) {
              const first = recData.find(t => typeof t.video_url === 'string' && t.video_url.trim());
              if (first && first.video_url) {
                const vurl = first.video_url.trim();
                // extract YouTube id if possible
                let vidId = '';
                const ytMatch = vurl.match(/[?&]v=([^&#]+)/) || vurl.match(/youtu\.be\/([^?#]+)/);
                if (ytMatch && ytMatch[1]) {
                  vidId = ytMatch[1];
                }
                recommended = {
                  id: vidId || '',
                  link: vurl,
                  title: (first.topic || baseQuery || '').toString(),
                  channel: 'Syllabus recommended',
                  channel_page: '',
                  thumbnail: '',
                  views: '',
                  channel_logo: '',
                  channel_logo_is_default: true,
                  duration: '',
                  recommended: true,
                };

                // Attempt to hydrate channel metadata from backend so logo/name show like other videos
                try {
                  const metaRes = await fetch(`${apiBase}/api/transcripts/meta`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: vurl }),
                  });
                  if (metaRes.ok) {
                    const meta = await metaRes.json();
                    if (meta && typeof meta === 'object') {
                      if (meta.channel_name) {
                        recommended.channel = meta.channel_name;
                      }
                      if (meta.channel_logo) {
                        recommended.channel_logo = meta.channel_logo;
                        recommended.channel_logo_is_default = false;
                      }
                      if (meta.channel_url) {
                        recommended.channel_page = meta.channel_url;
                      }
                    }
                  }
                } catch (metaErr) {
                  console.warn('Recommended video metadata lookup failed:', metaErr);
                }

                // Fallback to YouTube oEmbed for channel name + URL if backend metadata unavailable
                if (!recommended.channel_page || recommended.channel === 'Syllabus recommended') {
                  try {
                    const oembedRes = await fetch(`https://www.youtube.com/oembed?format=json&url=${encodeURIComponent(vurl)}`);
                    if (oembedRes.ok) {
                      const oembed = await oembedRes.json();
                      if (oembed && typeof oembed === 'object') {
                        if (oembed.author_name) {
                          recommended.channel = oembed.author_name;
                        }
                        if (oembed.author_url) {
                          recommended.channel_page = oembed.author_url;
                        }
                      }
                    }
                  } catch (oembedErr) {
                    console.warn('YouTube oEmbed lookup failed:', oembedErr);
                  }
                }
              }
            }
          }
        } catch (e) {
          console.warn('Recommended topic video lookup failed:', e);
        }

        const fetchOptions = relatedVideosAbort ? { signal: relatedVideosAbort.signal } : undefined;
        const response = await fetch(`${apiBase}/api/youtube/search?query=${encodeURIComponent(searchQuery)}&num=8`, fetchOptions);
        if (!response.ok) {
          throw new Error(`Search failed with status ${response.status}`);
        }
        const videos = await response.json();
        if (!Array.isArray(videos) || videos.length === 0) {
          const hadExisting = $relatedVideosCarousel && $relatedVideosCarousel.children.length > 0;
          if (hadExisting) {
            $relatedVideosSkeleton?.classList.add('hidden');
            $relatedVideosWrap?.classList.remove('hidden');
            $relatedVideosEmpty?.classList.add('hidden');
            if ($relatedVideosSummary) {
              $relatedVideosSummary.textContent = `Showing saved videos for "${searchQuery}".`;
            }
          } else {
            $relatedVideosSkeleton?.classList.add('hidden');
            $relatedVideosWrap?.classList.add('hidden');
            if ($relatedVideosEmpty) {
              $relatedVideosEmpty.textContent = 'No related videos found. Try a more specific topic.';
              $relatedVideosEmpty.classList.remove('hidden');
            }
            if ($relatedVideosSummary) {
              $relatedVideosSummary.textContent = `No videos found for "${searchQuery}".`;
            }
          }
          return;
        }
        const limited = videos.slice(0, 8);
        const finalList = recommended ? [recommended, ...limited] : limited;
        renderRelatedVideos(finalList, searchQuery, baseQuery, relatedVideosLanguage);
      } catch (error) {
        if (error?.name === 'AbortError') return;
        console.error('Related videos error:', error);
        const hadExisting = $relatedVideosCarousel && $relatedVideosCarousel.children.length > 0;
        if (hadExisting) {
          $relatedVideosSkeleton?.classList.add('hidden');
          $relatedVideosWrap?.classList.remove('hidden');
          $relatedVideosEmpty?.classList.add('hidden');
          if ($relatedVideosSummary) {
            $relatedVideosSummary.textContent = `Showing saved videos for "${searchQuery}".`;
          }
        } else {
          $relatedVideosSkeleton?.classList.add('hidden');
          $relatedVideosWrap?.classList.add('hidden');
          if ($relatedVideosEmpty) {
            $relatedVideosEmpty.textContent = 'Unable to load videos right now.';
            $relatedVideosEmpty.classList.remove('hidden');
          }
          if ($relatedVideosSummary) {
            $relatedVideosSummary.textContent = `Unable to load videos for "${searchQuery}".`;
          }
        }
      } finally {
        relatedVideosAbort = null;
      }
    }

    // ===== State =====
    let es = null;
    let lastMarkdown = '';
    let lastImageUrls = [];
    const VARIANTS = ['detailed', 'cheatsheet', 'simple'];
    let currentVariant = 'detailed';
    let currentCourseType = '';
    try { localStorage.setItem('paperx:lastVariant', currentVariant); } catch { }
    const noteKey = (v) => `paperx:lastNoteId:${v}`;
    let currentNoteId = localStorage.getItem(noteKey(currentVariant)) || (currentVariant === 'detailed' ? (localStorage.getItem('paperx:lastNoteId') || '') : '');
    function setVariantUI() {
      const act = currentVariant;
      [$variantDetailed, $variantCheatsheet, $variantSimple].forEach(btn => {
        if (!btn) return;
        const v = btn.dataset.variant;
        const on = v === act;
        btn.classList.toggle('bg-brand-600', on);
        btn.classList.toggle('text-white', on);
        btn.classList.toggle('shadow-neon', on);
        btn.classList.toggle('bg-transparent', !on);
        btn.classList.toggle('text-inherit', !on);
        btn.setAttribute('aria-selected', on ? 'true' : 'false');
      });
    }
    setVariantUI();
    function currentTopicOrHeading() {
      const fromHeading = (document.querySelector('#output h1')?.textContent || '').trim();
      const fromInput = ($topic.value || '').trim();
      return fromInput || fromHeading || '';
    }

    [$variantDetailed, $variantCheatsheet, $variantSimple].forEach(btn => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        const v = btn.dataset.variant;
        if (!v || !VARIANTS.includes(v)) return;
        currentVariant = v;
        try { localStorage.setItem('paperx:lastVariant', v); } catch { }
        setVariantUI();
        logEvent('Switch variant', v);
        console.log('[Variant] switch clicked:', v);
        checkMyNoteVisibility();
        // If a topic is present, auto-click Generate to regenerate for the new variant
        const t0 = ($topic.value || '').trim();
        if (t0) { $generate.click(); return; }
        // load last note for this variant if available; else auto-generate using current topic/heading
        const lastId = localStorage.getItem(noteKey(currentVariant)) || '';
        const fallbackGenerate = () => {
          const t = currentTopicOrHeading();
          if (!t) {
            snack('Enter a topic');
            console.warn('[Variant] No topic/heading to generate');
            return;
          }
          console.log('[Variant] auto-generate for topic:', t, 'variant:', currentVariant);
          logEvent('Auto-generate', `${currentVariant} • ${t}`);
          startGeneration(t, false);
        };
        if (lastId) {
          $meta.textContent = `Loading • ${lastId} • ${currentVariant}`;
          fetch(`${apiBase}/notes/${encodeURIComponent(lastId)}?variant=${encodeURIComponent(currentVariant)}`)
            .then(r => {
              if (!r.ok) return null;
              return r.json();
            })
            .then(data => {
              if (data && data.markdown) {
                renderMarkdown(data.markdown);
                renderImageGallery(data.image_urls || []);
                $meta.textContent = `Loaded • ${data.id || lastId} • ${currentVariant}`;
                currentNoteId = data.id || lastId;
                const loadedTopic = (document.querySelector('#output h1')?.textContent || $topic.value || '').trim();
                enableFlashcardAccess(currentNoteId, loadedTopic);
                enableMCQAccess(currentNoteId, loadedTopic);
              } else {
                console.warn('[Variant] No cached note for id; generating…', lastId, currentVariant);
                fallbackGenerate();
              }
            })
            .catch(err => { console.error('[Variant] Fetch by id failed:', err); fallbackGenerate(); });
        } else {
          fallbackGenerate();
        }
      });
    });
    let dense = false;
    let emphasis = localStorage.getItem('paperx:emphasis') === '1';

    // Initialize degree UI
    if ($degree) {
      $degree.addEventListener('change', onDegreeChange);
      loadDegreeOptions();
    }
    if ($degreeCustom) {
      $degreeCustom.addEventListener('input', onDegreeCustomInput);
    }
    // Always hide the entire degree selector field for automatic behavior
    if ($degreeRow) { $degreeRow.classList.add('hidden'); }
    // Resolve degree automatically from profile if possible; otherwise rely on stored degree or backend fallback
    (async () => {
      const ok = await autoResolveDegreeFromProfile();
      if (!ok) {
        // No profile/degree; if a stored degree exists, ensure hint shows it, else keep 'auto'
        const stored = getStoredDegree();
        if ($degree) {
          if (stored) {
            const match = Array.from($degree.options || []).some(o => (o.value || '').toLowerCase() === stored.toLowerCase());
            if (match) $degree.value = stored; else { $degree.value = 'custom'; if ($degreeCustom) $degreeCustom.value = stored; }
          } else {
            $degree.value = '';
          }
        }
      }
      updateDomainsHintDebounced();
    })();

    const storedTopic = (() => {
      try { return localStorage.getItem('paperx:lastTopic') || ''; } catch { return ''; }
    })();
    const storedVideos = (() => {
      try {
        const raw = localStorage.getItem('paperx:lastVideos');
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : null;
      } catch {
        return null;
      }
    })();
    const storedVideoLanguage = (() => {
      try { return localStorage.getItem('paperx:lastVideoLanguage') || ''; } catch { return ''; }
    })();

    if ($videoLanguage) {
      if (storedVideoLanguage && $videoLanguage.querySelector(`option[value="${storedVideoLanguage}"]`)) {
        $videoLanguage.value = storedVideoLanguage;
        relatedVideosLanguage = storedVideoLanguage;
      } else {
        relatedVideosLanguage = $videoLanguage.value || storedVideoLanguage || relatedVideosLanguage;
      }
    } else if (storedVideoLanguage) {
      relatedVideosLanguage = storedVideoLanguage;
    }

    if (storedTopic && storedVideos && storedVideos.length) {
      if (!$topic.value) $topic.value = storedTopic;
      if ($relatedVideosSection) $relatedVideosSection.classList.remove('hidden');
      const appliedLanguage = storedVideoLanguage || relatedVideosLanguage;
      const displayTopic = buildRelatedVideosQuery(storedTopic, appliedLanguage);
      renderRelatedVideos(storedVideos, displayTopic, storedTopic, appliedLanguage);
      relatedVideosLanguage = normalizeVideoLanguage(appliedLanguage) || 'English';
      relatedVideosTopic = storedTopic;
      relatedVideosFullQuery = displayTopic;
    } else if ($relatedVideosSection) {
      $relatedVideosSection.classList.remove('hidden');
      $relatedVideosSkeleton?.classList.remove('hidden');
      $relatedVideosWrap?.classList.add('hidden');
    }

    if (!$topic.value && storedTopic) {
      $topic.value = storedTopic;
      loadRelatedVideos(storedTopic, { force: true, language: relatedVideosLanguage });
    }

    // ===== Chips (suggested topics) =====
    document.querySelectorAll('.chip').forEach(ch => {
      ch.className = "ripple px-3 py-1.5 text-xs rounded-full border hover:bg-[var(--brand-soft)]";
      ch.style.borderColor = "var(--outline)";
      ch.addEventListener('click', () => {
        const value = ch.dataset.val || ch.textContent || '';
        $topic.value = value;
        loadRelatedVideos(value, { force: true });
      });
    });

    if ($refreshVideos) {
      $refreshVideos.addEventListener('click', () => {
        const current = ($topic.value || relatedVideosTopic || '').trim();
        loadRelatedVideos(current || relatedVideosTopic, { force: true });
      });
    }

    if ($videoLanguage) {
      $videoLanguage.addEventListener('change', () => {
        const selected = normalizeVideoLanguage($videoLanguage.value) || 'English';
        if (selected.toLowerCase() === (relatedVideosLanguage || '').toLowerCase()) return;
        relatedVideosLanguage = selected;
        try { localStorage.setItem('paperx:lastVideoLanguage', relatedVideosLanguage); } catch { }
        const current = ($topic.value || relatedVideosTopic || '').trim();
        if (current) {
          loadRelatedVideos(current, { force: true, language: relatedVideosLanguage });
        }
      });
    }

    if ($flashcardBtn) {
      $flashcardBtn.addEventListener('click', (event) => {
        event.preventDefault();
        openFlashcards();
      });
    }

    if ($mcqBtn) {
      $mcqBtn.addEventListener('click', (event) => {
        event.preventDefault();
        openMCQ();
      });
    }

    if ($myNoteBtn) {
      $myNoteBtn.addEventListener('click', async (event) => {
        event.preventDefault();
        const token = getAuthToken();
        if (!token) { snack('Sign in to use My note'); return; }
        const title = (document.querySelector('#output h1')?.textContent || $topic.value || '').trim();
        if (!title) { snack('No note loaded'); return; }
        try {
          const url = `${apiBase}/api/notes/edited?title=${encodeURIComponent(title)}&variant=${encodeURIComponent(currentVariant)}`;
          const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) { throw new Error((data && (data.detail || data.error)) || 'Load failed'); }
          if (data && data.markdown) {
            renderMarkdown(data.markdown);
            $meta.textContent = `My note • ${currentVariant}`;
            snack('Loaded My note');
          }
        } catch (e) { console.warn('My note error:', e); snack('Unable to load My note'); }
      });
    }

    if ($topic) {
      $topic.addEventListener('input', () => {
        const query = ($topic.value || '').trim();
        if (relatedVideosDebounce) {
          clearTimeout(relatedVideosDebounce);
        }
        relatedVideosDebounce = setTimeout(() => {
          if (!query) {
            loadRelatedVideos('', { force: true });
            return;
          }
          loadRelatedVideos(query);
        }, 600);
      });
    }

    // ===== Ripple =====
    document.addEventListener('click', (e) => {
      const b = e.target.closest('.ripple'); if (!b) return;
      const rect = b.getBoundingClientRect();
      const circle = document.createElement('span');
      circle.style.position = 'absolute';
      circle.style.left = `${e.clientX - rect.left}px`;
      circle.style.top = `${e.clientY - rect.top}px`;
      circle.style.width = circle.style.height = '0px';
      circle.style.borderRadius = '9999px';
      circle.style.background = 'currentColor';
      circle.style.opacity = '.12';
      circle.style.transform = 'translate(-50%,-50%)';
      circle.style.transition = 'width .5s ease, height .5s ease, opacity .8s ease';
      b.appendChild(circle);
      requestAnimationFrame(() => { circle.style.width = circle.style.height = Math.max(rect.width, rect.height) * 1.8 + 'px'; });
      setTimeout(() => { circle.style.opacity = '0'; setTimeout(() => circle.remove(), 300); }, 250);
    }, true);

    // ===== Theme (shared manager) =====
    (function initSharedTheme() {
      try {
        // Ensure global Theme is initialized (config.js handles apply + data-theme)
        if (window.Theme && typeof window.Theme.init === 'function') window.Theme.init();
        const mode = (window.Theme && window.Theme.get && window.Theme.get()) || (document.documentElement.classList.contains('dark') ? 'dark' : 'light');
        $themeBtn.textContent = mode === 'dark' ? 'Light' : 'Dark';
      } catch { }
      $themeBtn.addEventListener('click', () => {
        try {
          const mode = (window.Theme && window.Theme.toggle && window.Theme.toggle()) || (document.documentElement.classList.toggle('dark'), document.documentElement.classList.contains('dark') ? 'dark' : 'light');
          $themeBtn.textContent = mode === 'dark' ? 'Light' : 'Dark';
        } catch { }
      });
    })();

    // ===== Density Toggle =====
    function setDensity(on) {
      dense = on;
      document.body.classList.toggle('!text-[0.95rem]', on);
      Array.from(document.querySelectorAll('input,button,textarea,.chip')).forEach(el => {
        el.classList.toggle('!py-2', on);
        el.classList.toggle('!py-3', !on);
      });
    }
    $densityBtn.addEventListener('click', () => setDensity(!dense));

    // ===== Helpers =====
    function snack(msg) {
      $snack.textContent = msg;
      $snack.classList.remove('hidden');
      setTimeout(() => $snack.classList.add('hidden'), 1500);
    }

    function setEmphasis(on) {
      emphasis = on;
      $wrap.classList.toggle('emph-strong', on);
      localStorage.setItem('paperx:emphasis', on ? '1' : '0');
      // visual state on button
      $emphBtn.classList.toggle('bg-[var(--brand-soft)]', on);
      $emphBtn.textContent = on ? 'Emphasis On' : 'Emphasis';
    }

    function logEvent(title, detail = '') {
      try { console.debug('[Status]', title, detail || ''); } catch { }
    }

    function setBusy(b) {
      $generate.disabled = b; $cancel.disabled = !b; $topic.disabled = b;
      if ($regen) $regen.disabled = b;
      if ($regenMobile) $regenMobile.disabled = b;
    }

    // Loader controls scoped to the Final Output answer box
    function showOutputLoader() {
      if ($outputLoader) $outputLoader.style.display = 'flex';
      if ($wrap) $wrap.classList.add('loading');
    }
    function hideOutputLoader() {
      if ($outputLoader) $outputLoader.style.display = 'none';
      if ($wrap) $wrap.classList.remove('loading');
    }

    function postprocessLinks() {
      $output.querySelectorAll('a[href]').forEach(a => { a.target = '_blank'; a.rel = 'noopener noreferrer'; });
    }

    function buildTOC() {
      $toc.innerHTML = '';
      const hs = $output.querySelectorAll('h1, h2, h3');
      hs.forEach(h => {
        const level = h.tagName === 'H1' ? 1 : (h.tagName === 'H2' ? 2 : 3);
        const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-');
        h.id = id;
        const a = document.createElement('a');
        a.href = `#${id}`;
        a.textContent = h.textContent;
        a.className = `${level > 1 ? 'ml-3' : ''} block px-2 py-1 rounded hover:bg-[var(--brand-soft)]`;
        $toc.appendChild(a);
      });
    }

    function renderMarkdown(md) {
      lastMarkdown = md ?? '';
      const html = DOMPurify.sanitize(marked.parse(lastMarkdown));
      $output.innerHTML = html;
      $editor.value = lastMarkdown;

      // Track note view if we have content
      if (lastMarkdown && lastMarkdown.length > 50 && window.Analytics) {
        // Debounce or just track? Since renderMarkdown might be called multiple times during streaming/editing, 
        // we might want to be careful. But for now, assuming it's final render or major update.
        // Actually, let's track only if it seems substantial.
        window.Analytics.track('note_viewed', {
          variant: currentVariant || 'detailed',
          word_count: lastMarkdown.split(/\s+/).length
        });
      }

      // Mermaid blocks
      const mmd = $output.querySelectorAll('code.language-mermaid, pre code.language-mermaid');
      mmd.forEach((codeEl, i) => {
        const txt = codeEl.textContent;
        const pre = codeEl.closest('pre');
        const container = document.createElement('div');
        container.className = 'my-4';
        (pre || codeEl).replaceWith(container);
        try {
          mermaid.render('mmd-' + i + '-' + Date.now(), txt, (svg) => { container.innerHTML = svg; });
        } catch { }
      });

      // Syntax highlight
      try { hljs.highlightAll(); } catch { }

      // Math (KaTeX auto-render): support $...$, $$...$$, \(...\), \[...\]
      try {
        if (typeof renderMathInElement === 'function') {
          renderMathInElement($output, {
            delimiters: [
              { left: '$$', right: '$$', display: true },
              { left: '$', right: '$', display: false },
              { left: '\\(', right: '\\)', display: false },
              { left: '\\[', right: '\\]', display: true }
            ],
            throwOnError: false,
            ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          });
        }
      } catch { }

      // Transform inline [LABEL] citations into pills with favicons
      try { applyCitationPills(); } catch { }

      // Render CITATIONS section as one-line clickable list
      try { renderCitationsSection(); } catch { }

      postprocessLinks();
      buildTOC();
      // Update 'My note' visibility when content/title changes
      checkMyNoteVisibility();
    }

    function clearUI() {
      $images.innerHTML = '';
      $output.innerHTML = '';
      $toc.innerHTML = '';
      $progress.style.width = '0%';
      $meta.textContent = '';
      resetFlashcardAccess();
      resetMCQAccess();
      currentNoteId = '';
      lastImageUrls = [];
      // reset images skeleton (keep for images only)
      ['', '', ''].forEach(() => {
        const sk = document.createElement('div');
        sk.className = 'h-24 rounded-lg skeleton';
        $images.appendChild(sk);
      });
    }

    function renderImageGallery(urls) {
      if (!$images) return;
      const listRaw = Array.isArray(urls) ? urls.map(u => String(u || '').trim()).filter(u => !!u) : [];
      const list = Array.from(new Set(listRaw));
      lastImageUrls = list;
      $images.innerHTML = '';
      if (!list.length) return;
      list.slice(0, 9).forEach(url => {
        const a = document.createElement('a');
        a.href = url;
        a.target = '_blank';
        a.rel = 'noopener';
        const img = document.createElement('img');
        img.src = url;
        img.alt = 'reference image';
        img.className = 'w-full h-24 object-cover rounded-lg border';
        img.style.borderColor = 'var(--outline)';
        a.appendChild(img);
        $images.appendChild(a);
      });
    }

    function setProgress(stage) {
      const map = {
        start: 5, search_results: 20, fetch_start: 28, fetch_done: 46, merged_titles: 58,
        context_ready: 66, llm_start: 72, llm_done: 88, images: 94, final: 100
      };
      const v = map[stage] ?? 0;
      $progress.style.width = v + '%';
      document.querySelectorAll('.step').forEach(el => {
        el.classList.toggle('text-brand-700', el.dataset.step === stage);
      });
    }

    function normalizeCourseType(type) {
      const v = (type || '').trim().toLowerCase();
      return ['practical', 'theorey', 'maths'].includes(v) ? v : '';
    }

    function ensureWorkingSection(md, topic, courseType) {
      if (normalizeCourseType(courseType) !== 'practical') return md || '';
      const text = md || '';
      if (/^##\s*working\b/imu.test(text)) return text;
      const trimmed = text.trim();
      const working = [
        '## Working',
        `1. Prepare the required setup and apparatus for ${topic || 'this experiment'}.`,
        '2. Configure the environment and verify all safety constraints.',
        '3. Execute each step of the procedure methodically, capturing observations.',
        '4. Record measurements/results with units after every key action.',
        '5. Analyze the observations to derive the outcome, then clean up the setup.',
      ].join('\n');
      if (!trimmed) return working + '\n';
      return `${trimmed}\n\n${working}\n`;
    }

    async function fetchCourseTypeForTopic(topic) {
      const clean = (topic || '').trim();
      if (!clean) return '';
      try {
        const res = await fetch(`${apiBase}/api/syllabus/topics/by-title?topic=${encodeURIComponent(clean)}`);
        if (!res.ok) return '';
        const data = await res.json();
        if (!Array.isArray(data) || !data.length) return '';
        const match = data.find(t => t && t.course_type) || data[0];
        return normalizeCourseType(match && match.course_type);
      } catch (err) {
        console.warn('Course type lookup failed', err);
        return '';
      }
    }

    // ===== Streaming events =====
    document.getElementById('cancelBtn').addEventListener('click', () => {
      if (es) { es.close(); es = null; logEvent('Cancelled'); }
      hideOutputLoader();
      setBusy(false);
    });

    // Unified generator: supports force to bypass cache
    async function startGeneration(topic, force = false) {
      const t = (topic || '').trim();
      if (!t) { alert('Enter a topic'); return; }
      loadRelatedVideos(t, { force: true });
      if (es) { try { es.close(); } catch { } es = null; }
      clearUI();
      setBusy(true);
      showOutputLoader();
      currentCourseType = '';
      try {
        currentCourseType = await fetchCourseTypeForTopic(t);
      } catch (err) {
        console.warn('Course type lookup error', err);
      }
      const url = new URL(`${apiBase}/generate/stream`);
      url.searchParams.set('topic', t);
      if (force) url.searchParams.set('force', 'true');
      url.searchParams.set('variant', currentVariant);
      const degree = getSelectedDegree();
      if (degree) url.searchParams.set('degree', degree);
      if (currentCourseType) url.searchParams.set('course_type', currentCourseType);
      es = new EventSource(url.toString());

      es.addEventListener('open', () => { logEvent('Connected'); setProgress('start'); });
      es.addEventListener('error', () => { logEvent('Stream error'); hideOutputLoader(); setBusy(false); es && es.close(); es = null; });
      es.addEventListener('close', () => { hideOutputLoader(); setBusy(false); es && es.close(); es = null; });

      const on = (name, fn) => es.addEventListener(name, (ev) => { try { fn(JSON.parse(ev.data)); setProgress(name); } catch { } });

      on('start', (d) => {
        const allowed = Array.isArray(d.allowed_domains) ? d.allowed_domains : [];
        const deg = (d.degree || '').trim();
        logEvent('Start', `Allowed: ${allowed.join(', ')}`);
        if ($domainsHint) {
          if (deg && allowed.length) {
            const preview = allowed.slice(0, 4).join(', ');
            $domainsHint.textContent = `Degree: ${deg} • ${preview}${allowed.length > 4 ? '…' : ''}`;
          } else if (deg && !allowed.length) {
            $domainsHint.textContent = `Degree: ${deg} • web (fallback)`;
          } else if (!deg && allowed.length) {
            // No degree param, but backend allowed domains present (likely default)
            const preview = allowed.slice(0, 4).join(', ');
            $domainsHint.textContent = `Sources: ${preview}${allowed.length > 4 ? '…' : ''}`;
          } else {
            $domainsHint.textContent = 'Sources: auto';
          }
        }
      });
      on('search_results', (d) => logEvent('Searching', `${d.urls.length} results`));
      on('fetch_start', (d) => logEvent('Fetching', d.url));
      on('fetch_done', (d) => logEvent('Parsed', `${d.title} (${d.sections} sections)`));
      on('fetch_error', (d) => logEvent('Fetch error', d.error));
      on('merged_titles', (d) => logEvent('Merged titles', `${d.titles.length} unique`));
      on('context_ready', (d) => logEvent('Context ready', `${d.chars} chars`));
      on('llm_start', () => logEvent('LLM generating…'));
      on('llm_done', (d) => logEvent('LLM done', `${d.md_chars} chars`));
      on('images', (d) => {
        logEvent('Images', `${d.count} found`);
        renderImageGallery(d.image_urls || d.urls || []);
      });
      on('error', (d) => { logEvent('Error', d.message); hideOutputLoader(); setBusy(false); es && es.close(); es = null; });
      on('final', (d) => {
        renderImageGallery(d.image_urls || d.urls || lastImageUrls);
        const workingTopic = (d.title || d.topic || t);
        const mdToRender = ensureWorkingSection(d.markdown, workingTopic, currentCourseType);
        renderMarkdown(mdToRender);
        setEmphasis(emphasis);
        hideOutputLoader();
        if (d.id) {
          currentNoteId = d.id;
          try {
            localStorage.setItem(noteKey(currentVariant), currentNoteId);
            if (currentVariant === 'detailed') localStorage.setItem('paperx:lastNoteId', currentNoteId);
          } catch { }
          $meta.textContent = `Saved • ${currentNoteId} • ${currentVariant}`;
        }
        const detectedTopic = (() => {
          const fromHeading = (document.querySelector('#output h1')?.textContent || '').trim();
          if (fromHeading) return fromHeading;
          const fromPayload = (d.title || d.topic || '').trim();
          if (fromPayload) return fromPayload;
          const fromInput = ($topic.value || '').trim();
          if (fromInput) return fromInput;
          return relatedVideosTopic || '';
        })();
        if (currentNoteId) {
          enableFlashcardAccess(currentNoteId, detectedTopic);
          enableMCQAccess(currentNoteId, detectedTopic);
        }
        logEvent('Complete');
        setBusy(false); es && es.close(); es = null;
      });
    }

    // Regenerate from current topic or rendered H1 (force=true)
    $regen.addEventListener('click', () => {
      const fromTitle = (document.querySelector('#output h1')?.textContent || '').trim();
      const t = ($topic.value || fromTitle).trim();
      if (!t) { alert('Enter a topic'); return; }
      $topic.value = t;
      startGeneration(t, true);
    });
    if ($regenMobile) {
      $regenMobile.addEventListener('click', (e) => {
        e.preventDefault();
        if ($regen && !$regen.disabled) {
          $regen.click();
        } else {
          const fromTitle = (document.querySelector('#output h1')?.textContent || '').trim();
          const t = ($topic.value || fromTitle).trim();
          if (!t) { alert('Enter a topic'); return; }
          $topic.value = t;
          startGeneration(t, true);
        }
      });
    }

    document.getElementById('generateBtn').addEventListener('click', () => {
      const topic = ($topic.value || '').trim();
      console.log('[Generate] clicked topic:', topic, 'variant:', currentVariant);
      startGeneration(topic, false);
    });

    // ===== Toolbar actions =====
    if ($copy) $copy.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(lastMarkdown || ''); snack('Copied markdown'); }
      catch { snack('Copy failed'); }
    });

    $download.addEventListener('click', async () => {
      try {
        if (currentNoteId) {
          const res = await fetch(`${apiBase}/notes/${encodeURIComponent(currentNoteId)}/pdf`);
          if (!res.ok) throw new Error('PDF request failed');
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `${currentNoteId}.pdf`;
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          return;
        }
        // No note id yet — ad-hoc PDF from current content
        const title = (document.querySelector('#output h1')?.textContent || 'notes').trim();
        const res = await fetch(`${apiBase}/pdf`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, markdown: lastMarkdown || '' })
        });
        if (!res.ok) throw new Error('PDF request failed');
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `${(title || 'notes').toLowerCase().replace(/[^a-z0-9_.-]+/g, '_')}.pdf`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      } catch (e) {
        console.error(e);
        snack('PDF download failed');
      }
    });

    function setFullscreen(on) {
      const classes = ['fixed', 'inset-0', 'z-50', 'bg-[var(--surface)]', 'overflow-auto', 'p-6'];
      classes.forEach(c => $wrap.classList.toggle(c, on));
      $expand.textContent = on ? 'Exit' : 'Fullscreen';
      if ($fsCtrl) $fsCtrl.classList.toggle('hidden', !on);
    }
    $expand.addEventListener('click', () => { setFullscreen(!$wrap.classList.contains('fixed')); });
    $fsExit?.addEventListener('click', () => setFullscreen(false));
    $fsHome?.addEventListener('click', () => { window.location.href = 'index.html'; });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && $wrap.classList.contains('fixed')) setFullscreen(false); });

    // Emphasis toggle
    setEmphasis(emphasis);
    $emphBtn.addEventListener('click', () => setEmphasis(!emphasis));

    // ===== Citations: parser + transformer =====
    function parseCitationsFromMarkdown(mdText) {
      const map = {};
      if (!mdText) return map;
      const secMatch = mdText.match(/^##\s*CITATIONS\b[\s\S]*$/im);
      if (!secMatch) return map;
      const startIdx = secMatch.index || 0;
      // find next section header after CITATIONS
      const after = mdText.slice(startIdx + secMatch[0].split('\n')[0].length);
      const nextHeaderIdx = after.search(/^##\s+/m);
      const secBody = nextHeaderIdx >= 0 ? after.slice(0, nextHeaderIdx) : after;
      // Patterns: "- [LABEL]: URL", "- [LABEL] - URL", or "- LABEL: URL"
      const lines = secBody.split(/\n+/);
      const urlRe = /(https?:\/\/[^\s)\]]+)/i;
      for (const line of lines) {
        const m1 = line.match(/\[\s*([A-Za-z0-9_-]{2,20})\s*\][^\n]*?(https?:\/\/[^\s)\]]+)/i);
        if (m1) { map[m1[1].trim()] = m1[2].trim(); continue; }
        const m2 = line.match(/^\s*[-*]?\s*([A-Za-z0-9_-]{2,20})\s*[:\-–—]\s*(https?:\/\/\S+)/i);
        if (m2) { map[m2[1].trim()] = m2[2].trim(); continue; }
        const m3 = line.match(urlRe);
        if (m3) {
          // try to infer label from domain if missing explicit label
          try {
            const u = new URL(m3[1]);
            const host = u.hostname.replace(/^www\./, '');
            const guess = host.split('.')[0];
            if (guess && !map[guess]) map[guess] = m3[1];
          } catch { }
        }
      }
      return map;
    }

    function applyCitationPills() {
      const citations = parseCitationsFromMarkdown(lastMarkdown || '');
      const labels = Object.keys(citations);
      if (!labels.length) return;

      // Mark all nodes inside the CITATIONS section to exclude from transform
      const h2s = $output.querySelectorAll('h2');
      let citationsMarked = false;
      for (const h of h2s) {
        if ((h.textContent || '').trim().toUpperCase() === 'CITATIONS') {
          // mark the heading as part of citations section
          if (h.nodeType === 1) h.setAttribute('data-citations-section', '1');
          let cur = h.nextSibling;
          while (cur) {
            if (cur.nodeType === 1 && /^(H1|H2)$/i.test(cur.nodeName)) break;
            if (cur.nodeType === 1) {
              cur.setAttribute('data-citations-section', '1');
            }
            cur = cur.nextSibling;
          }
          citationsMarked = true;
          break;
        }
      }

      const isInExcluded = (node) => {
        if (!node) return false;
        let n = node.parentNode;
        while (n && n !== $output) {
          if (n.nodeType === 1) {
            if (n.hasAttribute && n.hasAttribute('data-citations-section')) return true;
            const tag = n.nodeName;
            if (tag === 'PRE' || tag === 'CODE' || tag === 'SCRIPT' || tag === 'STYLE' || tag === 'A') return true;
          }
          n = n.parentNode;
        }
        return false;
      };

      const pattern = /\[([^\[\]]+)\]/g; // [GFG] or [GFG, TP]
      const walker = document.createTreeWalker($output, NodeFilter.SHOW_TEXT);
      const toProcess = [];
      while (walker.nextNode()) {
        const node = walker.currentNode;
        if (!node.nodeValue || node.nodeValue.indexOf('[') === -1) continue;
        if (isInExcluded(node)) continue;
        toProcess.push(node);
      }

      toProcess.forEach(node => {
        const text = node.nodeValue;
        pattern.lastIndex = 0;
        let m;
        let lastIdx = 0;
        let replaced = false;
        const frag = document.createDocumentFragment();

        while ((m = pattern.exec(text))) {
          const inside = m[1];
          const tokens = inside.split(',').map(s => s.trim()).filter(Boolean);
          const valid = tokens.filter(t => citations[t]);
          if (!valid.length) continue;
          // prepend text before match
          if (m.index > lastIdx) frag.appendChild(document.createTextNode(text.slice(lastIdx, m.index)));
          // add pills for each valid label
          valid.forEach((lab, idx) => {
            const href = citations[lab];
            let host = '';
            try { host = new URL(href).hostname.replace(/^www\./, ''); } catch { }
            const a = document.createElement('a');
            if (href) a.href = href;
            a.target = '_blank'; a.rel = 'noopener';
            a.className = 'citation-pill';
            a.title = href || '';
            const img = document.createElement('img');
            img.alt = '';
            img.loading = 'lazy';
            img.referrerPolicy = 'no-referrer';
            img.src = host ? `https://www.google.com/s2/favicons?domain=${host}&sz=32` : '';
            a.appendChild(img);
            const span = document.createElement('span');
            span.textContent = lab;
            a.appendChild(span);
            frag.appendChild(a);
            if (idx !== valid.length - 1) frag.appendChild(document.createTextNode(' '));
          });
          lastIdx = pattern.lastIndex;
          replaced = true;
        }
        if (replaced) {
          if (lastIdx < text.length) frag.appendChild(document.createTextNode(text.slice(lastIdx)));
          node.parentNode.replaceChild(frag, node);
        }
      });
    }

    function renderCitationsSection() {
      const citations = parseCitationsFromMarkdown(lastMarkdown || '');
      const labels = Object.keys(citations);
      if (!labels.length) return;

      const h2s = $output.querySelectorAll('h2');
      let h2 = null;
      for (const h of h2s) {
        if ((h.textContent || '').trim().toUpperCase() === 'CITATIONS') { h2 = h; break; }
      }
      if (!h2) return;

      // Remove existing section content (list/paragraphs) until next H1/H2
      let cur = h2.nextSibling;
      const toRemove = [];
      while (cur) {
        if (cur.nodeType === 1 && /^(H1|H2)$/i.test(cur.nodeName)) break;
        toRemove.push(cur);
        cur = cur.nextSibling;
      }
      toRemove.forEach(n => n.parentNode && n.parentNode.removeChild(n));

      // Build our one-line list
      const wrap = document.createElement('div');
      wrap.className = 'citations-list';

      labels.forEach(lab => {
        const href = citations[lab];
        const a = document.createElement('a');
        a.className = 'citation-item';
        a.href = href;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.title = href;
        // Visible text: LABEL — URL
        a.textContent = `${lab} — ${href}`;
        wrap.appendChild(a);
      });

      h2.insertAdjacentElement('afterend', wrap);
    }

    let queryTopic = (() => {
      try { return new URLSearchParams(window.location.search).get('topic')?.trim() || ''; }
      catch { return ''; }
    })();

    // Load last note on open (persistence)
    (async function loadLastNote() {
      if (queryTopic) return;
      const id = (localStorage.getItem(noteKey(currentVariant)) || (currentVariant === 'detailed' ? localStorage.getItem('paperx:lastNoteId') : '')); if (!id) return;
      try {
        const res = await fetch(`${apiBase}/notes/${encodeURIComponent(id)}?variant=${encodeURIComponent(currentVariant)}`);
        if (!res.ok) return;
        const data = await res.json();
        if (data?.markdown) {
          renderMarkdown(data.markdown);
          renderImageGallery(data.image_urls || []);
          $meta.textContent = `Loaded • ${id} • ${currentVariant}`;
          currentNoteId = data?.id || id;
          const derivedTopic = (
            (data?.title || '')
            || (document.querySelector('#output h1')?.textContent || '')
            || storedTopic
            || ($topic.value || '')
          ).trim();
          if (currentNoteId) {
            enableFlashcardAccess(currentNoteId, derivedTopic);
            enableMCQAccess(currentNoteId, derivedTopic);
          }
        }
      } catch { }
    })();

    // If opened with ?topic=..., prefill and auto-generate
    (function maybeAutoStartFromQuery() {
      if (!queryTopic) return;
      $topic.value = queryTopic;
      startGeneration(queryTopic, false);
      setTimeout(() => document.getElementById('output')?.scrollIntoView({ behavior: 'smooth' }), 50);
      try { history.replaceState(null, '', window.location.pathname + window.location.hash); } catch { }
      queryTopic = '';
    })();

    // Edit / Save
    function setEditMode(on) {
      $output.classList.toggle('hidden', on);
      $editor.classList.toggle('hidden', !on);
      $save.classList.toggle('hidden', !on);
      if (typeof $editToggle !== 'undefined' && $editToggle) {
        $editToggle.textContent = on ? 'Preview' : 'Edit';
      }
      if (on) {
        $editor.value = lastMarkdown;
        requestAnimationFrame(() => {
          if ($editor && typeof $editor.focus === 'function') {
            try {
              $editor.focus({ preventScroll: true });
            } catch (err) {
              $editor.focus();
            }
          }
        });
      } else {
        renderMarkdown($editor.value);
      }
    }
    let isEditing = false;
    if (typeof $editToggle !== 'undefined' && $editToggle) {
      $editToggle.addEventListener('click', () => {
        const hasMarkdown = !!(lastMarkdown && lastMarkdown.trim());
        if (!hasMarkdown) { snack('Generate notes first'); return; }
        isEditing = !isEditing;
        setEditMode(isEditing);
      });
    }
    $save.addEventListener('click', async () => {
      const md = $editor.value || '';
      if (!currentNoteId) {
        const topic = (document.querySelector('#output h1')?.textContent || $topic.value || 'Untitled').trim();
        const res = await fetch(`${apiBase}/notes?variant=${encodeURIComponent(currentVariant)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ topic, markdown: md, image_urls: lastImageUrls })
        });
        if (res.ok) {
          const data = await res.json();
          currentNoteId = data.id;
          try {
            localStorage.setItem(noteKey(currentVariant), currentNoteId);
            if (currentVariant === 'detailed') localStorage.setItem('paperx:lastNoteId', currentNoteId);
          } catch { }
          $meta.textContent = `Saved • ${currentNoteId} • ${currentVariant}`;
          renderImageGallery(data.image_urls || lastImageUrls);
          renderMarkdown(md);
          isEditing = false; setEditMode(false);
          logEvent('Saved', currentNoteId);
          snack('Saved');
        } else { logEvent('Save failed'); snack('Save failed'); }
        return;
      }
      const res = await fetch(`${apiBase}/notes/${encodeURIComponent(currentNoteId)}?variant=${encodeURIComponent(currentVariant)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ markdown: md, image_urls: lastImageUrls })
      });
      if (res.ok) {
        const data = await res.json().catch(() => ({}));
        renderImageGallery((data && data.image_urls) || lastImageUrls);
        renderMarkdown(md);
        isEditing = false; setEditMode(false);
        $meta.textContent = `Saved • ${currentNoteId} • ${currentVariant}`;
        logEvent('Saved', currentNoteId);
        snack('Saved');
      } else { logEvent('Save failed'); snack('Save failed'); }
    });

    // ===== AI Adjust (ephemeral) =====
    (function () {
      const btnSummarize = document.getElementById('aiSummarize');
      const btnExpand = document.getElementById('aiExpand');
      const btnSimplify = document.getElementById('aiSimplify');
      const btnCustom = document.getElementById('aiCustomApply');
      const btnClear = document.getElementById('aiClearPrompt');
      const btnRevert = document.getElementById('aiRevert');
      const promptBox = document.getElementById('aiCustomPrompt');
      const statusEl = document.getElementById('aiAdjustStatus');
      const endpoint = `${apiBase}/api/notes/transform`;
      let originalSnapshot = null; // first markdown before any transform

      function currentMarkdown() {
        return isEditing ? ($editor.value || '') : (lastMarkdown || '');
      }
      function applyMarkdown(md) {
        if (isEditing) { $editor.value = md; }
        renderMarkdown(md);
      }
      function setBusy(b) {
        const btns = [btnSummarize, btnExpand, btnSimplify, btnCustom, btnClear, btnRevert];
        btns.forEach(bt => bt && (bt.disabled = b));
        statusEl.classList.toggle('hidden', !b);
        if (b) statusEl.textContent = 'Processing...';
      }
      async function run(mode, custom) {
        const md = currentMarkdown().trim();
        if (!md) { snack('Nothing to transform'); return; }
        if (!originalSnapshot) originalSnapshot = md; // capture once
        setBusy(true);
        try {
          const res = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode, markdown: md, prompt: custom }) });
          if (!res.ok) { throw new Error(await res.text() || 'Transform failed'); }
          const data = await res.json();
          if (data.markdown) {
            applyMarkdown(data.markdown);
            btnRevert.classList.remove('hidden');
            snack(`${mode[0].toUpperCase() + mode.slice(1)} done`);
          }
        } catch (e) {
          console.error(e); snack('AI error');
          if (!originalSnapshot) originalSnapshot = null;
        } finally { setBusy(false); }
      }
      btnSummarize?.addEventListener('click', () => run('summarize'));
      btnExpand?.addEventListener('click', () => run('expand'));
      btnSimplify?.addEventListener('click', () => run('simplify'));
      btnCustom?.addEventListener('click', () => {
        const instr = (promptBox.value || '').trim();
        if (!instr) { snack('Enter instruction'); promptBox.focus(); return; }
        run('custom', instr);
      });
      btnClear?.addEventListener('click', () => { promptBox.value = ''; promptBox.focus(); });
      btnRevert?.addEventListener('click', () => {
        if (originalSnapshot) { applyMarkdown(originalSnapshot); originalSnapshot = null; btnRevert.classList.add('hidden'); snack('Reverted'); }
      });
    })();
  </script>

  <script>
    // Floating AI Assistant toggle
    (function () {
      const fab = document.getElementById('aiFab');
      const panel = document.getElementById('aiPanel');
      const closeBtn = document.getElementById('aiClosePanel');
      if (!fab || !panel) return;
      function toggle(open) {
        if (open === undefined) open = !panel.classList.contains('open');
        panel.classList.toggle('open', open);
        if (open) {
          panel.classList.remove('pointer-events-none');
          panel.querySelector('#aiCustomPrompt')?.focus();
        } else {
          panel.classList.add('pointer-events-none');
        }
      }
      // Toggle on each click now
      fab.addEventListener('click', () => toggle());
      closeBtn?.addEventListener('click', () => toggle(false));
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') toggle(false); });
      document.addEventListener('click', (e) => {
        if (!panel.classList.contains('open')) return;
        if (panel.contains(e.target) || e.target === fab) return;
        const rect = panel.getBoundingClientRect();
        if (e.clientX < rect.left - 20 || e.clientY < rect.top - 20) toggle(false);
      });
    })();
  </script>
</body>

</html>